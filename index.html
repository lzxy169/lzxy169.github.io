<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Inconsolata:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.lzxy169.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":true,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="It is about walking the path and responding to the heart.">
<meta property="og:type" content="website">
<meta property="og:title" content="Navy&#39;s blog">
<meta property="og:url" content="https://blog.lzxy169.com/index.html">
<meta property="og:site_name" content="Navy&#39;s blog">
<meta property="og:description" content="It is about walking the path and responding to the heart.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Navy">
<meta property="article:tag" content="lzxy169, blog, navy">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.lzxy169.com/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Navy's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/pjax.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/wavedrom.min.js","integrity":"sha256-INLAoJc6quTNfiMWkGZniYO2cxE8mHpddnLow1m6RFs="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js" defer></script>


  <script src="/js/third-party/pace.js" defer></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/3.0.1/quicklink.umd.js" integrity="sha256-44BednzIpUeQJcY8qtLyarFu0UCCTbgmWOvaoehiFQQ=" crossorigin="anonymous" defer></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":false,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://blog.lzxy169.com/"}</script>
  <script src="/js/third-party/quicklink.js" defer></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Navy's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Navy's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">2</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">4</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">9</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Navy"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Navy</p>
  <div class="site-description" itemprop="description">It is about walking the path and responding to the heart.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lzxy169" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lzxy169" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lzxy169@gmail.com" title="E-Mail → mailto:lzxy169@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.lzxy169.com/2018/07/02/APM-Open-sources/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Navy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Navy's blog">
      <meta itemprop="description" content="It is about walking the path and responding to the heart.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Navy's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/07/02/APM-Open-sources/" class="post-title-link" itemprop="url">APM Open sources</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-07-02 13:02:56" itemprop="dateCreated datePublished" datetime="2018-07-02T13:02:56+08:00">2018-07-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2018-08-02 13:09:52" itemprop="dateModified" datetime="2018-08-02T13:09:52+08:00">2018-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1，<a target="_blank" rel="noopener" href="https://github.com/plausiblelabs/plcrashreporter">PLCrashReporter</a>， <a target="_blank" rel="noopener" href="https://www.plcrashreporter.org/">Home</a>: Crash reporting for iOS and Mac OS X</p>
<p>2，<a target="_blank" rel="noopener" href="https://github.com/kstenerud/KSCrash">KSCrash</a>: The Ultimate iOS Crash Reporter</p>
<p>3，<a target="_blank" rel="noopener" href="https://github.com/facebook/FBRetainCycleDetector">FBRetainCycleDetector</a>: iOS library to help detecting retain cycles in runtime.</p>
<p>4，<a target="_blank" rel="noopener" href="https://github.com/featuretower/GYMonitor">GYMonitor</a>: base on PLCrashReporter: A collection of code for profiling iOS app, such as monitoring FPS.</p>
<p>5，<a target="_blank" rel="noopener" href="https://github.com/Tencent/MLeaksFinder">MLeaksFinder</a>: Find memory leaks in your iOS app at develop time. base on FBRetainCycleDetector</p>
<p>6，<a target="_blank" rel="noopener" href="https://github.com/jspahrsummers/libextobjc">libextobjc</a>: A Cocoa library to extend the Objective-C programming language.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.lzxy169.com/2018/06/02/AFNetworking-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Navy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Navy's blog">
      <meta itemprop="description" content="It is about walking the path and responding to the heart.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Navy's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/06/02/AFNetworking-analysis/" class="post-title-link" itemprop="url">AFNetworking 解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-06-02 13:02:41" itemprop="dateCreated datePublished" datetime="2018-06-02T13:02:41+08:00">2018-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2018-08-02 13:10:24" itemprop="dateModified" datetime="2018-08-02T13:10:24+08:00">2018-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h3><p>NSURLSession 使用 NSURLRequest 来包含请求信息，来生成各种类型的 Task，使用 NSURLSessionConfiguration 来生成配置信息<br>调用 - (void)resume 来发送请求， 生成 NSURLResponse 来返回请求的信息。回调的方式有delegate，和block两种形式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface NSURLSessionDataTask : NSURLSessionTask</span><br><span class="line">@interface NSURLSessionUploadTask : NSURLSessionDataTask</span><br><span class="line">@interface NSURLSessionDownloadTask : NSURLSessionTask</span><br><span class="line">@interface NSURLSessionStreamTask : NSURLSessionTask</span><br><span class="line"></span><br><span class="line">@protocol NSURLSessionDelegate &lt;NSObject&gt;</span><br><span class="line">@protocol NSURLSessionTaskDelegate &lt;NSURLSessionDelegate&gt;</span><br><span class="line">@protocol NSURLSessionDataDelegate &lt;NSURLSessionTaskDelegate&gt;</span><br><span class="line">@protocol NSURLSessionDownloadDelegate &lt;NSURLSessionTaskDelegate&gt;</span><br><span class="line">@protocol NSURLSessionStreamDelegate &lt;NSURLSessionTaskDelegate&gt;</span><br></pre></td></tr></table></figure>

<h3 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h3><p>AFNetworking是封装的NSURLSession的网络请求。</p>
<p><strong>AFNetworking核心由五个模块组成：</strong><br>SessionManager ：主要对象 NSURLSession 对象进行了进一步的封装<br>Request&#x2F;Response Serialization，提供了与请求数据和解析数据相关的操作接口<br>SecurityPolicy，提供了与安全性相关的操作接口，主要是证书验证<br>NetworkReachabilityManager，提供了与网络状态监听相关的操作接口<br>以及的UIKit的一些类扩展，提供了大量网络请求过程中与UI界面显示相关的操作接口，通常用于网络请求过程中提示，使用户交互更加友好</p>
<p><strong>SessionManager：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface AFURLSessionManager : NSObject &lt;NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate, NSSecureCoding, NSCopying&gt;</span><br><span class="line"></span><br><span class="line">@interface AFHTTPSessionManager : AFURLSessionManager &lt;NSSecureCoding, NSCopying&gt;</span><br></pre></td></tr></table></figure>

<p><strong>HTTPMethod：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@&quot;GET&quot;，@&quot;HEAD&quot;，@&quot;POST&quot;，@&quot;PUT&quot;，@&quot;PATCH&quot;，@&quot;DELETE&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Request：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@protocol AFURLRequestSerialization &lt;NSObject, NSSecureCoding, NSCopying&gt;</span><br><span class="line">@interface AFHTTPRequestSerializer : NSObject &lt;AFURLRequestSerialization&gt;</span><br><span class="line">@interface AFJSONRequestSerializer : AFHTTPRequestSerializer</span><br><span class="line">@interface AFPropertyListRequestSerializer : AFHTTPRequestSerializer</span><br></pre></td></tr></table></figure>

<p><strong>Response：</strong><br>@protocol AFURLResponseSerialization &lt;NSObject, NSSecureCoding, NSCopying&gt;<br>@interface AFHTTPResponseSerializer : NSObject <AFURLResponseSerialization><br>@interface AFJSONResponseSerializer : AFHTTPResponseSerializer<br>@interface AFXMLParserResponseSerializer : AFHTTPResponseSerializer<br>@interface AFPropertyListResponseSerializer : AFHTTPResponseSerializer<br>@interface AFImageResponseSerializer : AFHTTPResponseSerializer<br>@interface AFCompoundResponseSerializer : AFHTTPResponseSerializer</p>
<h3 id="YTKNetwork"><a href="#YTKNetwork" class="headerlink" title="YTKNetwork"></a>YTKNetwork</h3><p>YTKNetwork 由 Request， RequestAgent，NetworkConfig组成，对 AFNetworking 的封装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YTKRequestMethod：</span><br><span class="line">YTKRequestMethodGET,</span><br><span class="line">YTKRequestMethodPOST,</span><br><span class="line">YTKRequestMethodHEAD,</span><br><span class="line">YTKRequestMethodPUT,</span><br><span class="line">YTKRequestMethodDELETE,</span><br><span class="line">YTKRequestMethodPATCH,</span><br><span class="line"></span><br><span class="line">Request：</span><br><span class="line">@protocol YTKRequestDelegate &lt;NSObject&gt;</span><br><span class="line">@interface YTKBaseRequest : NSObject</span><br><span class="line"></span><br><span class="line">@protocol YTKBatchRequestDelegate &lt;NSObject&gt;</span><br><span class="line">@interface YTKBatchRequest : NSObject</span><br><span class="line"></span><br><span class="line">@protocol YTKChainRequestDelegate &lt;NSObject&gt;</span><br><span class="line">@interface YTKChainRequest : NSObject</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.lzxy169.com/2018/04/16/arc-record/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Navy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Navy's blog">
      <meta itemprop="description" content="It is about walking the path and responding to the heart.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Navy's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/16/arc-record/" class="post-title-link" itemprop="url">ARC(Automatic Reference Counting)简记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-16 10:29:09" itemprop="dateCreated datePublished" datetime="2018-04-16T10:29:09+08:00">2018-04-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2018-08-02 13:09:39" itemprop="dateModified" datetime="2018-08-02T13:09:39+08:00">2018-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="ARC概述"><a href="#ARC概述" class="headerlink" title="ARC概述"></a>ARC概述</h2><p>　　在Objective-C中采用Automatic Reference Counting(ARC)机制，让编译器(<a target="_blank" rel="noopener" href="http://clang.org/">clang</a>)和运行时库协助(<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">objc4</a>)来进行内存管理。</p>
<h3 id="内存管理的思考方式"><a href="#内存管理的思考方式" class="headerlink" title="内存管理的思考方式"></a>内存管理的思考方式</h3><ul>
<li>自己生成的对象，自己持有</li>
<li>非自己生成的对象，自己也能持有</li>
<li>不再需要自己持有的对象时释放</li>
<li>非自己持有的对象无法释放</li>
</ul>
<p><strong>对象操作与Objective-C方法的对应：</strong></p>
<table>
<thead>
<tr>
<th>对象操作</th>
<th>Objective-C方法</th>
</tr>
</thead>
<tbody><tr>
<td>生成并持有对象</td>
<td>alloc&#x2F;new&#x2F;copy&#x2F;mutableCopy 等方法</td>
</tr>
<tr>
<td>持有对象</td>
<td>retain方法</td>
</tr>
<tr>
<td>释放对象</td>
<td>release方法</td>
</tr>
<tr>
<td>废弃对象</td>
<td>dealloc方法</td>
</tr>
</tbody></table>
<blockquote>
<p>“自己”：对象的使用环境</p>
</blockquote>
<p><strong>苹果采用散列表(引用计数表)来管理引用计数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    CFLock_t lock;</span><br><span class="line">    CFBasicHashRef table;</span><br><span class="line"><span class="comment">//    uint8_t padding[64 - sizeof(CFBasicHashRef) - sizeof(CFLock_t)];</span></span><br><span class="line">&#125; __NSRetainCounters[NUM_EXTERN_TABLES];</span><br><span class="line"></span><br><span class="line">CF_EXPORT <span class="type">uintptr_t</span> __CFDoExternRefOperation(<span class="type">uintptr_t</span> op, id obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nil == obj) HALT;</span><br><span class="line">    <span class="type">uintptr_t</span> idx = <span class="built_in">EXTERN_TABLE_IDX</span>(obj);</span><br><span class="line">    <span class="type">uintptr_t</span> disguised = <span class="built_in">DISGUISE</span>(obj);</span><br><span class="line">    CFLock_t *lock = &amp;__NSRetainCounters[idx].lock;</span><br><span class="line">    CFBasicHashRef table = __NSRetainCounters[idx].table;  <span class="comment">// 取得对象对应的散列表</span></span><br><span class="line">    <span class="type">uintptr_t</span> count;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">300</span>:   <span class="comment">// increment</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">350</span>:   <span class="comment">// increment, no event</span></span><br><span class="line">        __CFLock(lock);</span><br><span class="line">    <span class="built_in">CFBasicHashAddValue</span>(table, disguised, disguised);</span><br><span class="line">        __CFUnlock(lock);</span><br><span class="line">        <span class="keyword">if</span> (__CFOASafe &amp;&amp; op != <span class="number">350</span>) __CFRecordAllocationEvent(__kCFObjectRetainedEvent, obj, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">uintptr_t</span>)obj;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">400</span>:   <span class="comment">// decrement</span></span><br><span class="line">        <span class="keyword">if</span> (__CFOASafe) __CFRecordAllocationEvent(__kCFObjectReleasedEvent, obj, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">450</span>:   <span class="comment">// decrement, no event</span></span><br><span class="line">        __CFLock(lock);</span><br><span class="line">        count = (<span class="type">uintptr_t</span>)<span class="built_in">CFBasicHashRemoveValue</span>(table, disguised);</span><br><span class="line">        __CFUnlock(lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> == count;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">        __CFLock(lock);</span><br><span class="line">        count = (<span class="type">uintptr_t</span>)<span class="built_in">CFBasicHashGetCountOfKey</span>(table, disguised);</span><br><span class="line">        __CFUnlock(lock);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/CF/">CF-1153.18&#x2F;CFRuntime.c</a></p>
<p><strong>CFBasicHashRef</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CF_PRIVATE CFBasicHashRef <span class="title">CFBasicHashCreate</span><span class="params">(CFAllocatorRef allocator, CFOptionFlags flags, <span class="type">const</span> CFBasicHashCallbacks *cb)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> __CFBasicHash) - <span class="built_in">sizeof</span>(CFRuntimeBase);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; kCFBasicHashHasKeys) size += <span class="built_in">sizeof</span>(CFBasicHashValue *); <span class="comment">// keys</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; kCFBasicHashHasCounts) size += <span class="built_in">sizeof</span>(<span class="type">void</span> *); <span class="comment">// counts</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; kCFBasicHashHasHashCache) size += <span class="built_in">sizeof</span>(<span class="type">uintptr_t</span> *); <span class="comment">// hashes</span></span><br><span class="line">    CFBasicHashRef ht = (CFBasicHashRef)_CFRuntimeCreateInstance(allocator, <span class="built_in">CFBasicHashGetTypeID</span>(), size, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == ht) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ht-&gt;bits.finalized = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.hash_style = (flags &gt;&gt; <span class="number">13</span>) &amp; <span class="number">0x3</span>;</span><br><span class="line">    ht-&gt;bits.fast_grow = (flags &amp; kCFBasicHashAggressiveGrowth) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.counts_width = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.strong_values = (flags &amp; kCFBasicHashStrongValues) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.strong_keys = (flags &amp; kCFBasicHashStrongKeys) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.weak_values = (flags &amp; kCFBasicHashWeakValues) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.weak_keys = (flags &amp; kCFBasicHashWeakKeys) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.int_values = (flags &amp; kCFBasicHashIntegerValues) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.int_keys = (flags &amp; kCFBasicHashIntegerKeys) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.indirect_keys = (flags &amp; kCFBasicHashIndirectKeys) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.num_buckets_idx = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.used_buckets = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.deleted = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.mutations = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;bits.strong_values &amp;&amp; ht-&gt;bits.weak_values) HALT;</span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;bits.strong_values &amp;&amp; ht-&gt;bits.int_values) HALT;</span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;bits.strong_keys &amp;&amp; ht-&gt;bits.weak_keys) HALT;</span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;bits.strong_keys &amp;&amp; ht-&gt;bits.int_keys) HALT;</span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;bits.weak_values &amp;&amp; ht-&gt;bits.int_values) HALT;</span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;bits.weak_keys &amp;&amp; ht-&gt;bits.int_keys) HALT;</span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;bits.indirect_keys &amp;&amp; ht-&gt;bits.strong_keys) HALT;</span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;bits.indirect_keys &amp;&amp; ht-&gt;bits.weak_keys) HALT;</span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;bits.indirect_keys &amp;&amp; ht-&gt;bits.int_keys) HALT;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> offset = <span class="number">1</span>;</span><br><span class="line">    ht-&gt;bits.keys_offset = (flags &amp; kCFBasicHashHasKeys) ? offset++ : <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.counts_offset = (flags &amp; kCFBasicHashHasCounts) ? offset++ : <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.hashes_offset = (flags &amp; kCFBasicHashHasHashCache) ? offset++ : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">    ht-&gt;bits.hashes_offset = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.strong_values = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.strong_keys = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.weak_values = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;bits.weak_keys = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ht-&gt;bits.__kret = <span class="built_in">CFBasicHashGetPtrIndex</span>((<span class="type">void</span> *)cb-&gt;retainKey);</span><br><span class="line">    ht-&gt;bits.__vret = <span class="built_in">CFBasicHashGetPtrIndex</span>((<span class="type">void</span> *)cb-&gt;retainValue);</span><br><span class="line">    ht-&gt;bits.__krel = <span class="built_in">CFBasicHashGetPtrIndex</span>((<span class="type">void</span> *)cb-&gt;releaseKey);</span><br><span class="line">    ht-&gt;bits.__vrel = <span class="built_in">CFBasicHashGetPtrIndex</span>((<span class="type">void</span> *)cb-&gt;releaseValue);</span><br><span class="line">    ht-&gt;bits.__kdes = <span class="built_in">CFBasicHashGetPtrIndex</span>((<span class="type">void</span> *)cb-&gt;copyKeyDescription);</span><br><span class="line">    ht-&gt;bits.__vdes = <span class="built_in">CFBasicHashGetPtrIndex</span>((<span class="type">void</span> *)cb-&gt;copyValueDescription);</span><br><span class="line">    ht-&gt;bits.__kequ = <span class="built_in">CFBasicHashGetPtrIndex</span>((<span class="type">void</span> *)cb-&gt;equateKeys);</span><br><span class="line">    ht-&gt;bits.__vequ = <span class="built_in">CFBasicHashGetPtrIndex</span>((<span class="type">void</span> *)cb-&gt;equateValues);</span><br><span class="line">    ht-&gt;bits.__khas = <span class="built_in">CFBasicHashGetPtrIndex</span>((<span class="type">void</span> *)cb-&gt;hashKey);</span><br><span class="line">    ht-&gt;bits.__kget = <span class="built_in">CFBasicHashGetPtrIndex</span>((<span class="type">void</span> *)cb-&gt;getIndirectKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (CFIndex idx = <span class="number">0</span>; idx &lt; offset; idx++) &#123;</span><br><span class="line">        ht-&gt;pointers[idx] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_MEMORY_COUNTERS</span></span><br><span class="line">    <span class="type">int64_t</span> size_now = <span class="built_in">OSAtomicAdd64Barrier</span>((<span class="type">int64_t</span>) <span class="built_in">CFBasicHashGetSize</span>(ht, <span class="literal">true</span>), &amp; __CFBasicHashTotalSize);</span><br><span class="line">    <span class="keyword">while</span> (__CFBasicHashPeakSize &lt; size_now &amp;&amp; !<span class="built_in">OSAtomicCompareAndSwap64Barrier</span>(__CFBasicHashPeakSize, size_now, &amp; __CFBasicHashPeakSize));</span><br><span class="line">    <span class="type">int64_t</span> count_now = <span class="built_in">OSAtomicAdd64Barrier</span>(<span class="number">1</span>, &amp; __CFBasicHashTotalCount);</span><br><span class="line">    <span class="keyword">while</span> (__CFBasicHashPeakCount &lt; count_now &amp;&amp; !<span class="built_in">OSAtomicCompareAndSwap64Barrier</span>(__CFBasicHashPeakCount, count_now, &amp; __CFBasicHashPeakCount));</span><br><span class="line">    <span class="built_in">OSAtomicAdd32Barrier</span>(<span class="number">1</span>, &amp;__CFBasicHashSizes[ht-&gt;bits.num_buckets_idx]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ht;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/CF/">CF-1153.18&#x2F;CFBasicHash.c</a></p>
<h3 id="所有权修饰符"><a href="#所有权修饰符" class="headerlink" title="所有权修饰符"></a>所有权修饰符</h3><p>　　Objective-C 中为了处理对象，将类型定义为 id 类型或各种对象类型<br>　　id 类型用于隐藏类型的类名，相当于C语言中的 void *。</p>
<ul>
<li><strong>__strong：</strong> 表示对对象的“强引用”。持有强引用的变量，在超出其作用域时强引用失效，所以自动地释放自己持有的对象，对象的所有者不存在，因此废弃该对象。该修饰符是 id 类型和对象类型默认的所有权修饰符。</li>
<li><strong>__weak：</strong> 表示对对象的“弱引用”。持有弱引用的变量，在超出其作用域时，对象即被释放。在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且被赋值为 nil (空弱引用)。</li>
<li><strong>__unsafe_unretained：</strong> 附有该修饰符的变量不属于编译器的内存管理对象。既不持有对象的强引用也不持有对象的弱引用，只是表示对象，若该对象被废弃，其为悬垂指针。</li>
<li><strong>__autoreleasing：</strong></li>
</ul>
<p><strong>属性声明的属性与所有权修饰符的对应关系</strong></p>
<table>
<thead>
<tr>
<th>属性声明的属性</th>
<th>所有权修饰符</th>
</tr>
</thead>
<tbody><tr>
<td>assign</td>
<td>__unsafe_unretained</td>
</tr>
<tr>
<td>copy</td>
<td>__strong (赋值的是被复制的对象)</td>
</tr>
<tr>
<td>retain</td>
<td>__strong</td>
</tr>
<tr>
<td>strong</td>
<td>__strong</td>
</tr>
<tr>
<td>weak</td>
<td>__weak</td>
</tr>
<tr>
<td>unsafe_unretained</td>
<td>__unsafe_unretained</td>
</tr>
</tbody></table>
<blockquote>
<p>内存泄漏就是应当废弃的对象在超出其生存周期后继续存在。相互引用(循环引用)容易发生内存泄漏。</p>
</blockquote>
<blockquote>
<p>野指针是指向“垃圾”内存（不可用内存）的指针。不是NULL指针。</p>
</blockquote>
<blockquote>
<p>悬垂指针是指指向曾经存在的对象，但该对象已经不再存在了。</p>
</blockquote>
<blockquote>
<p>附有 __strong 和 __weak 修饰符的变量类似于C++中的智能指针 std::shared_ptr 和 std::weak_ptr。std::shared_ptr 可通过引用计数来持有C++ 类实例，std::weak_ptr 可避免循环引用。</p>
</blockquote>
<h3 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h3><p>　　类似于C语言中的自动变量(局部变量)的特性。若某自动变量超出其作用域，改自动变量将被自动废弃。</p>
<p><strong>autorelease 的具体用法：</strong></p>
<ul>
<li>生成并持有 NSAutoreleasePool 对象</li>
<li>调用已分配对象的 autorelease 实例方法</li>
<li>废弃 NSAutoreleasePool 对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* ARC无效 */</span><br><span class="line">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">// 等同于 objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">[obj autorelease];</span><br><span class="line">// 等同于 objc_autorelease(obj);</span><br><span class="line"></span><br><span class="line">[pool drain];</span><br><span class="line">// 等同于 objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">/* ARC有效 */</span><br><span class="line">@autoreleasepool &#123; // 显式</span><br><span class="line">    id __autoreleasing obj = [[NSObject alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@autoreleasepool &#123; // 非显式</span><br><span class="line">    // 非自己生成并持有的对象</span><br><span class="line">    id __strong obj = [NSMutableArray array];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　ARC有效时，指定“@autoreleasepool 块”来代替“NSAutoreleasePool 类对象生成，持有以及废弃”。通过将对象赋值给附加了__autoreleasing 修饰符的变量来代替调用 autorelease 方法。对象赋值给附有 __autoreleasing 修饰符的变量等价于在ARC无效时调用对象的 autorelease 方法，即对象被注册到 autoreleasepool 。</p>
<p>　　非显式地使用 __autoreleasing 也可以。这是由于编译器会检查<strong>方法名</strong>是否以 alloc&#x2F;new&#x2F;copy&#x2F;mutableCopy 开始，如果不是则自动将返回的对象注册到 autoreleasepool 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (id)array &#123;</span><br><span class="line">    id obj = [[NSMutableArray alloc] init];</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　以上为取得非自己生成并持有的对象时被调用方法的源代码示例。因为没有显式指定所有权修饰符所以 id obj 同附有 __strong 修饰符的 id __strong obj 是完全一样的。由于 return 使得对象变量超出其作用域，所以该强引用对应的自己持有的对象会被自动释放，但该对象作为函数的返回值，编译器会自动将其注册到 autoreleasepool 中。</p>
<p>　　id 的指针(id *obj)或对象的指针(NSObject **obj)在没有显式指定时会被附加上 __autoreleasing 修饰符。使用附有 __autoreleasing 修饰符的变量作为对象取得参数，都会注册到 autoreleasepool ， 并取得非自己生成并持有的对象。 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (BOOL)performOperationWithError:(NSError * __autoreleasing *)error &#123;</span><br><span class="line">    *error = [[NSError alloc] initWithDomain:@&quot;Domain&quot; code:0 userInfo:nil];</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用方法</span><br><span class="line">NSError __strong *error = nil;</span><br><span class="line">BOOL result = [obj performOperationWithError: &amp;error];</span><br><span class="line"></span><br><span class="line">编译器转化上述代码为下：</span><br><span class="line"></span><br><span class="line">NSError __strong *error = nil;</span><br><span class="line">NSError __autoreleasing *tmp = error;</span><br><span class="line">BOOL result = [obj performOperationWithError: &amp;tmp];</span><br><span class="line">error = tmp;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在显式地指定 __autoreleasing 修饰符时，必须注意对象变量要为自动变量(包括局部变量，函数，以及方法参数)。</p>
</blockquote>
<p>　　在访问附有 __weak 修饰符的变量时，实际上必定要访问注册到 autoreleasepool 的对象。为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id __strong obj0 = [[NSObject alloc] init];</span><br><span class="line">id __weak obj1 = obj0;</span><br><span class="line">NSLog(@&quot;class = %@&quot;, [obj1 class]);</span><br><span class="line"></span><br><span class="line">编译器转化上述代码为下：</span><br><span class="line">id __weak obj1 = obj0;</span><br><span class="line">id __autoreleasing tmp = obj1;</span><br><span class="line">NSLog(@&quot;class = %@&quot;, [tmp class]);</span><br></pre></td></tr></table></figure>
<p>　　这是因为 __weak 修饰符只持有对象的弱引用，而在访问引用对象的过程中，该对象有可能被废弃。如果把要访问的对象注册到 autoreleasepool 中，那么在 @autoreleasepool 块结束之前都能确保该对象存在。</p>
<p>　　在Cocoa框架中，相当于主循环的 NSRunLoop 或者在其他程序可运行的地方，对 NSAutoreleasePool 对象进行生成，持有和废弃处理。</p>
<p>　　Cocoa框架中有很多类方法用于返回 autorelease 的对象。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id array = [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">id array2 = [[[NSMutableArray alloc] initWithCapacity:1] autorelease];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>无论ARC是否有效，调试用的非公开函数 __objc__autoreleasePoolPrint() 都可使用。利用这一函数可调试注册到 autoreleasepool 上的对象。</p>
</blockquote>
<p><strong>autorelease 的实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutoreleasePoolPage</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">id *<span class="title">add</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        id *ret = next;  <span class="comment">// faster than `return next-1` because of aliasing</span></span><br><span class="line">        *next++ = obj;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">releaseAll</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">releaseUntil</span>(<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> id <span class="title">autorelease</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(obj);</span><br><span class="line">        <span class="built_in">assert</span>(!obj-&gt;<span class="built_in">isTaggedPointer</span>());</span><br><span class="line">        id *dest __unused = <span class="built_in">autoreleaseFast</span>(obj);</span><br><span class="line">        <span class="built_in">assert</span>(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title">push</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        id *dest;</span><br><span class="line">        <span class="keyword">if</span> (DebugPoolAllocation) &#123;</span><br><span class="line">            <span class="comment">// Each autorelease pool starts on a new pool page.</span></span><br><span class="line">            dest = <span class="built_in">autoreleaseNewPage</span>(POOL_BOUNDARY);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dest = <span class="built_in">autoreleaseFast</span>(POOL_BOUNDARY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">        <span class="keyword">return</span> dest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">void</span> *token)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        AutoreleasePoolPage *page;</span><br><span class="line">        id *stop;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token == (<span class="type">void</span>*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">            <span class="comment">// Popping the top-level placeholder pool.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">hotPage</span>()) &#123;</span><br><span class="line">                <span class="comment">// Pool was used. Pop its contents normally.</span></span><br><span class="line">                <span class="comment">// Pool pages remain allocated for re-use as usual.</span></span><br><span class="line">                <span class="built_in">pop</span>(<span class="built_in">coldPage</span>()-&gt;<span class="built_in">begin</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Pool was never used. Clear the placeholder.</span></span><br><span class="line">                <span class="built_in">setHotPage</span>(nil);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page = <span class="built_in">pageForPointer</span>(token);</span><br><span class="line">        stop = (id *)token;</span><br><span class="line">        <span class="keyword">if</span> (*stop != POOL_BOUNDARY) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stop == page-&gt;<span class="built_in">begin</span>()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">                <span class="comment">// Start of coldest page may correctly not be POOL_BOUNDARY:</span></span><br><span class="line">                <span class="comment">// 1. top-level pool is popped, leaving the cold page in place</span></span><br><span class="line">                <span class="comment">// 2. an object is autoreleased with no pool</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Error. For bincompat purposes this is not </span></span><br><span class="line">                <span class="comment">// fatal in executables built with old SDKs.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">badPop</span>(token);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintPoolHiwat) <span class="built_in">printHiwat</span>();</span><br><span class="line"></span><br><span class="line">        page-&gt;<span class="built_in">releaseUntil</span>(stop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// memory: delete empty children</span></span><br><span class="line">        <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  page-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// special case: delete everything during page-per-pool debugging</span></span><br><span class="line">            AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">            page-&gt;<span class="built_in">kill</span>();</span><br><span class="line">            <span class="built_in">setHotPage</span>(parent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DebugMissingPools  &amp;&amp;  page-&gt;<span class="built_in">empty</span>()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            <span class="comment">// special case: delete everything for pop(top) </span></span><br><span class="line">            <span class="comment">// when debugging missing autorelease pools</span></span><br><span class="line">            page-&gt;<span class="built_in">kill</span>();</span><br><span class="line">            <span class="built_in">setHotPage</span>(nil);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">            <span class="comment">// hysteresis: keep one empty child if page is more than half full</span></span><br><span class="line">            <span class="keyword">if</span> (page-&gt;<span class="built_in">lessThanHalfFull</span>()) &#123;</span><br><span class="line">                page-&gt;child-&gt;<span class="built_in">kill</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">                page-&gt;child-&gt;child-&gt;<span class="built_in">kill</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> r __unused = <span class="built_in">pthread_key_init_np</span>(AutoreleasePoolPage::key, </span><br><span class="line">                                             AutoreleasePoolPage::tls_dealloc);</span><br><span class="line">        <span class="built_in">assert</span>(r == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">objc4-706&#x2F;runtime&#x2F;NSObject.mm</a></p>
<h2 id="ARC规则"><a href="#ARC规则" class="headerlink" title="ARC规则"></a>ARC规则</h2><ul>
<li>不能使用 retain&#x2F;release&#x2F;retainCount&#x2F;autorelease。在ARC下，内存管理是编译器的工作。</li>
<li>不能使用 NSAllocateObject&#x2F;NSDeallocateObject</li>
<li>须遵守内存管理的方法命名规则。alloc&#x2F;new&#x2F;copy&#x2F;mutableCopy，以这些名称开始的方法在返回对象时，必须返回给调用方所应当持有的对象。以 init 开始的方法必须是实例方法，并且必须要返回对象。返回的对象应为 id 类型或该方法声明类的对象类型，抑或是该类的超类或子类型。该返回对象不注册到 autoreleasepool 中。 基本上只是对 alloc 方法返回值的对象进行初始化处理并返回该对象。</li>
<li>不要显式调用 dealloc。 无论 ARC 是否有效，只要对象的所有者都不持有该对象，该对象就被废弃。对象被废弃时，不管 ARC 是否有效，都会调用对象的 dealloc 方法。</li>
<li>使用@autoreleasepool 块代替 NSAutoreleasePool </li>
<li>不能使用区域(NSZone)</li>
<li>对象型变量不能作为C语言结构体(struct&#x2F;union)的成员。C语言的规范上没有方法来管理结构体成员的生存周期。要把对象型变量加入到结构体成员中时，可强制转换为 void *，或者时附加 __unsafe_unretained 。 附有该修饰符的变量不属于编译器的内存管理对象。</li>
<li>显式转换“ id ”和“ void * ”。</li>
</ul>
<p><strong>__bridge 转换</strong>  单纯的赋值转换。注意转换为 void * 的 __bridge 转换其安全性与赋值给 __unsafe_unretained 修饰符相近，甚至会更低。如果不注意赋值对象的所有者，就会因悬垂指针而导致程序崩溃。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">void *p = (__bridge void *)obj;</span><br><span class="line">id o = (__bridge id)p;</span><br></pre></td></tr></table></figure>

<p><strong>__bridge_retained 转换</strong> 可使要转换赋值的变量也持有所赋值的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">void *p = (__bridge_retained void *)obj;</span><br></pre></td></tr></table></figure>

<p><strong>__bridge_transfer 转换</strong> 被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">void *p = (__bridge_retained void *)obj;</span><br><span class="line"></span><br><span class="line">id obj1 = (__bridge_transfer id)p;</span><br></pre></td></tr></table></figure>

<p>　　以下函数可用于 Objective-C 对象与 Core Foundation 对象之间的相互变换，即 Toll-Free-Bridge 转化。由于这种转换不需要使用额外的CPU资源，因此也被称为“免费桥”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CFTypeRef CFBridgingRetain(id  _Nullable X) &#123;</span><br><span class="line">    return (__bridge_retained CFTypeRef)X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id CFBridgingRelease(CFTypeRef  _Nullable X) &#123;</span><br><span class="line">        return (__bridge_transfer id)X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSMutableArray *obj = [[NSMutableArray alloc] initWithCapacity:1];</span><br><span class="line">CFMutableArrayRef cfobject = CFBridgingRetain(obj);</span><br><span class="line">CFShow(cfobject);</span><br><span class="line">CFRelease(cfobject);</span><br><span class="line"></span><br><span class="line">CFMutableArrayRef cfobject = CFArrayCreateMutable(kCFAllocatorDefault, 0, NULL);</span><br><span class="line">id obj = CFBridgingRelease(cfobject);</span><br></pre></td></tr></table></figure>

<h2 id="ARC实现"><a href="#ARC实现" class="headerlink" title="ARC实现"></a>ARC实现</h2><ul>
<li>**__strong：**表示对对象的“强引用”。引用计数为1。持有强引用的变量，在超出其作用域时强引用失效，所以自动地释放自己持有的对象，对象的所有者不存在，因此废弃该对象。该修饰符是 id 类型和对象类型默认的所有权修饰符。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id __strong obj = [[NSObject alloc] init];</span><br><span class="line"></span><br><span class="line">// 编译器的模拟代码：</span><br><span class="line">id obj = objc_msgSend(NSObject, @selector(alloc));</span><br><span class="line">objc_msgSend(obj, @selector(init));</span><br><span class="line">objc_release(obj);</span><br></pre></td></tr></table></figure>

<p>　　使用 alloc&#x2F;new&#x2F;copy&#x2F;mutableCopy 以外的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (id)array &#123;</span><br><span class="line">    return [[NSMutableArray alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">// NSMutableArray 类的 array 类方法 通过编译器转换后的模拟代码：</span><br><span class="line">+ (id)array &#123;</span><br><span class="line">    id obj = objc_msgSend(NSMutableArray, @selector(alloc));</span><br><span class="line">    objc_msgSend(obj, @selector(init));</span><br><span class="line">    return objc_autoreleaseReturnValue(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id __strong obj = [NSMutableArray array];</span><br><span class="line">// 编译器的模拟代码：</span><br><span class="line">id obj = objc_msgSend(NSMutableArray, @selector(array));</span><br><span class="line">objc_retainAutoreleasedReturnValue(obj)</span><br><span class="line">objc_release(obj);</span><br></pre></td></tr></table></figure>
<p>　　objc_autoreleaseReturnValue() 函数会检查使用该函数的方法或者函数调用方的执行命令列表，如果方法或者函数的调用方调用了方法或者函数后紧接着调用 objc_retainAutoreleasedReturnValue() 函数，那么就不将返回的对象注册到 autoreleasepool 中，而是直接传递到方法或者函数的调用方。<br>而返回的对象则存储在 TLS 中， Thread Local Storage（TLS）线程局部存储，目的很简单，将一块内存作为某个线程专有的存储，以 key-value 的形式进行读写。在返回的对象身上调用 objc_autoreleaseReturnValue() 方法时， runtime 将这个返回的对象 obj 储存在 TLS 中，然后直接返回这个 obj （不调用autorelease）；同时，在外部接收这个返回的对象的方法 objc_retainAutoreleasedReturnValue() 里发现 TLS 中正好存了这个对象，那么直接返回这个 obj （不调用retain）。于是乎，调用方和被调方利用 TLS 做中转，很有默契的免去了对返回值的内存管理。这就是在ARC下，runtime 对 autorelease 返回值的优化策略。</p>
<blockquote>
<p>Thread-local storage（线程局部存储）指向 hot page ，即最新添加的 autoreleased 对象所在的那个 page 。???</p>
</blockquote>
<ul>
<li><strong>__weak：</strong> 表示对对象的“弱引用”。弱引用并不持有对象，不会改变赋值给附有 __weak 修饰符的变量的引用计数。持有弱引用的变量，在超出其作用域时，对象即被释放。在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且被赋值为 nil (空弱引用)。<strong>使用</strong> __weak 修饰符的变量，即是使用注册到 autoreleasepool 中的对象，该对象的引用计数会加1。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id __strong obj = [[NSObject alloc] init];</span><br><span class="line"></span><br><span class="line">id __weak obj1 = obj;</span><br><span class="line">NSLog(@&quot;%@&quot;, obj1);</span><br><span class="line"></span><br><span class="line">// 编译器的模拟代码：</span><br><span class="line">id obj1;</span><br><span class="line">objc_initWeak(&amp;obj1, obj);</span><br><span class="line">id tmp = objc_loadWeakRetained(&amp;obj1);</span><br><span class="line">objc_autorelease(tmp);</span><br><span class="line">NSLog(@&quot;%@&quot;, tmp);</span><br><span class="line">objc_destroyWeak(&amp;obj1);</span><br><span class="line"></span><br><span class="line">id objc_initWeak(id *location, id newObj) &#123;</span><br><span class="line">    return storeWeak(location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void objc_destroyWeak(id *location) &#123;</span><br><span class="line">    (void)storeWeak(location, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　storeWeak() 函数把第二参数的赋值对象的地址作为键值key，将第一参数的附有 __weak 修饰符的变量的地址作为键值 value 注册到 __weak 表中。如果第二参数(key)为 nil， 则把变量的地址(value)从 weak 表中删除。</p>
<p>　　weak 表与引用计数表相同，作为散列表被实现。如果使用 weak 表，将废弃对象的地址作为键值key进行检索，就能高速地获取对应的附有 __weak 修饰符的变量的地址。另外，由于一个对象可同时赋值给多个附有 __weak 修饰符的变量中，所以对于一个键值key，可注册多个变量的地址。<br>　　<br>　　objc_loadWeakRetained() 函数取出附有 __weak 修饰符变量所引用的对象并 retain。objc_autorelease() 函数将对象注册到 autoreleasepool 中 。如果大量使用附有 __weak修饰符的变量，注册到 autoreleasepool 中的对象也会大量的增加，因此在使用附有 __weak修饰符的变量时，最好先暂时赋值给附有 __strong 修饰符的变量后使用。</p>
<blockquote>
<p>对象废弃执行的动作</p>
</blockquote>
<ol>
<li>objc_release</li>
<li>当引用计数为0执行dealloc</li>
<li>_objc_rootDealloc</li>
<li>object_dispose</li>
<li>objc_destructInstance</li>
<li>objc_clear_deallocating</li>
</ol>
<blockquote>
<p>对象被弃用时最后调用objc_clear_deallocating 函数执行的动作</p>
</blockquote>
<ol>
<li>从 weak 表中获取废弃对象的地址为键值key的记录</li>
<li>将包含在记录中的所有附有 __weak 修饰符变量的地址，赋值为 nil </li>
<li>从weak 表中删除该记录</li>
<li>从引用计数表中删除废弃对象的地址为键值的记录</li>
</ol>
<p>　　如果大量使用附有 __weak 修饰符的变量，则会消耗相应的CPU资源，良策是只在需要避免循环引用时使用 __weak 修饰符。</p>
<ul>
<li><p><strong>__unsafe_unretained：</strong> 附有该修饰符的变量不属于编译器的内存管理对象。既不持有对象的强引用也不持有对象的弱引用，只是表示对象，若该对象被废弃，其为悬垂指针。</p>
</li>
<li><p><strong>__autoreleasing：</strong> 将对象赋值给有 __autoreleasing 修饰符的变量，等同于 ARC 无效时调用对象 autorelease 方法，会将对象注册到 autoreleasepool 中，对象的引用计数加1。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">    id __autoreleasing obj = [[NSObject alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">/* 编译器的模拟代码 */</span><br><span class="line">id pool = objc_autoreleasePoolPush();</span><br><span class="line">id obj = objc_msgSend(NSObject, @selector(alloc));</span><br><span class="line">objc_msgSend(obj, @selector(init));</span><br><span class="line">objc_autorelease(obj);</span><br><span class="line">objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">    id __autoreleasing obj = [NSMutableArray array];</span><br><span class="line">&#125;</span><br><span class="line">// 编译器的模拟代码：</span><br><span class="line">id pool = objc_autoreleasePoolPush();</span><br><span class="line">id obj = objc_msgSend(NSMutableArray, @selector(array));</span><br><span class="line">objc_retainAutoreleasedReturnValue(obj);</span><br><span class="line">objc_autorelease(obj);</span><br><span class="line">objc_autoreleasePoolPop(pool);</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.lzxy169.com/2018/04/13/c:c++-memory-management/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Navy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Navy's blog">
      <meta itemprop="description" content="It is about walking the path and responding to the heart.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Navy's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/13/c:c++-memory-management/" class="post-title-link" itemprop="url">C/C++内存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-13 11:33:58" itemprop="dateCreated datePublished" datetime="2018-04-13T11:33:58+08:00">2018-04-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2018-08-02 13:09:17" itemprop="dateModified" datetime="2018-08-02T13:09:17+08:00">2018-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>　　在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局&#x2F;静态存储区和常量存储区。</p>
<ol>
<li><p>**栈：**在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
</li>
<li><p>**堆：**就是那些由new分配的内存块，它们的释放编译器不去管，由应用程序去控制，一般一个new就要对应一个delete。如果没有手动释放掉，那么在程序结束后，操作系统会自动回收。</p>
</li>
<li><p>**自由存储区：**就是那些由malloc等分配的内存块，它和堆是十分相似的，不过它是用free来结束自己的生命的。</p>
</li>
<li><p>**全局静态存储区：**全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。</p>
</li>
<li><p>**常量存储区：**这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。</p>
</li>
</ol>
<blockquote>
<p>明确区分堆与栈</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; </span><br><span class="line">    <span class="keyword">delete</span> []p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这条短短的一句话就包含了堆与栈，看到new，我们首先就应该想到，我们分配了一块堆内存，那么指针p呢？他分配的是一块栈内存。<br>　　所以这行代码的意思就是：在栈内存中存放了一个指向一块堆内存的指针p。在程序会先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块内存的首地址，放入栈中。delete []p，这是为了告诉编译器：我删除的是一个数组，编译器就会根据相应的Cookie信息去进行释放内存的工作。</p>
<h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><ol>
<li><p>**管理方式：**对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</p>
</li>
<li><p>**空间大小：**一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，一般系统默认设置栈段为8M、4M、2M或1M。</p>
</li>
<li><p>**碎片问题：**对于堆来讲，频繁的new&#x2F;delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。</p>
</li>
<li><p>**生长方向：**对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。</p>
</li>
<li><p>**分配方式：**堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloc函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p>
</li>
<li><p>**分配效率：**栈是系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C&#x2F;C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构&#x2F;操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。<br>　　从这里我们可以看到，堆和栈相比，由于大量new&#x2F;delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。</p>
</li>
</ol>
<p>　　虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。<br>　　无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果,就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候debug可是相当困难的：）</p>
<h3 id="控制C-的内存分配"><a href="#控制C-的内存分配" class="headerlink" title="控制C++的内存分配"></a>控制C++的内存分配</h3><p>　　在嵌入式系统中使用C++的一个常见问题是内存分配，即对new 和 delete 操作符的失控。<br>　　具有讽刺意味的是，问题的根源却是C++对内存的管理非常的容易而且安全。具体地说，当一个对象被消除时，它的析构函数能够安全的释放所分配的内存。<br>　　这当然是个好事情，但是这种使用的简单性使得程序员们过度使用new 和 delete，而不注意在嵌入式C++环境中的因果关系。并且，在嵌入式系统中，由于内存的限制，频繁的动态分配不定大小的内存会引起很大的问题以及堆破碎的风险。<br>　　作为忠告，保守的使用内存分配是嵌入式环境中的第一原则。<br>　　但当你必须要使用new和delete时，你不得不控制C++中的内存分配。你需要用一个全局的new 和delete来代替系统的内存分配符，并且一个类一个类的重载new和delete。<br>　　一个防止堆破碎的通用方法是从不同固定大小的内存池中分配不同类型的对象。对每个类重载new 和delete就提供了这样的控制。</p>
<h4 id="重载全局的new和delete操作符"><a href="#重载全局的new和delete操作符" class="headerlink" title="重载全局的new和delete操作符"></a>重载全局的new和delete操作符</h4><p>　　可以很容易地重载new 和 delete 操作符，如下所示:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span> *p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这段代码可以代替默认的操作符来满足内存分配的请求。出于解释C++的目的，我们也可以直接调用malloc() 和free()。<br>　　也可以对单个类的new 和 delete操作符重载。这是你能灵活的控制对象的内存分配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *p)</span></span>;</span><br><span class="line">    <span class="comment">// .. other members here ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> *TestClass::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="type">void</span> *p = <span class="built_in">malloc</span>(size); <span class="comment">// Replace this with alternative allocator</span></span><br><span class="line">    <span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> TestClass::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// Replace this with alternative de-allocator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　所有TestClass 对象的内存分配都采用这段代码。更进一步，任何从TestClass 继承的类也都采用这一方式，除非它自己也重载了new 和 delete 操作符。通过重载new 和 delete 操作符的方法，你可以自由地采用不同的分配策略，从不同的内存池中分配不同的类对象。</p>
<h4 id="为单个的类重载new-和delete"><a href="#为单个的类重载new-和delete" class="headerlink" title="为单个的类重载new[]和delete[]"></a>为单个的类重载new[]和delete[]</h4><p>　　必须小心对象数组的分配。你可能希望调用到被你重载过的new 和 delete 操作符，但并不如此。内存的请求被定向到全局的new[]和delete[] 操作符，而这些内存来自于系统堆。<br>　　C++将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，你同样需要重载new[] 和 delete[]操作符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[ ](<span class="type">size_t</span> size);</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[ ](<span class="type">void</span> *p);</span><br><span class="line">    <span class="comment">// .. other members here ..</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> *TestClass::<span class="keyword">operator</span> <span class="keyword">new</span>[ ](<span class="type">size_t</span> size)&#123;</span><br><span class="line">    <span class="type">void</span> *p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> TestClass::<span class="keyword">operator</span> <span class="keyword">delete</span>[ ](<span class="type">void</span> *p)&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    TestClass *p = <span class="keyword">new</span> TestClass[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// ... etc ...</span></span><br><span class="line">    <span class="keyword">delete</span>[ ] p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　但是注意：对于多数C++的实现，new[]操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。在你的内存分配机制重要考虑的这一点。你应该尽量避免分配对象数组，从而使你的内存分配策略简单。</p>
<h3 id="常见的内存错误及其对策"><a href="#常见的内存错误及其对策" class="headerlink" title="常见的内存错误及其对策"></a>常见的内存错误及其对策</h3><p>　　发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。</p>
<blockquote>
<p>常见的内存错误及其对策如下：</p>
</blockquote>
<ol>
<li>**内存分配未成功，却使用了它。**编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!&#x3D;NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p&#x3D;&#x3D;NULL) 或if(p!&#x3D;NULL)进行防错处理。</li>
<li>**内存分配虽然成功，但是尚未初始化就引用它。**犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。</li>
<li>**内存分配成功并且已经初始化，但操作越过了内存的边界。**例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。</li>
<li>**忘记了释放内存，造成内存泄露。**含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new&#x2F;delete同理）。</li>
<li><strong>释放了内存却继续使用它。</strong> 有三种情况：<br>(1). 程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。<br>(2). 函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。<br>(3). 使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。</li>
</ol>
<blockquote>
<p>那么如何避免产生野指针呢？这里列出了5条规则，平常写程序时多注意一下，养成良好的习惯。</p>
</blockquote>
<p>***　　规则1：用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。<br>　　规则2：不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。<br>　　规则3：避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。<br>　　规则4：动态内存的申请与释放必须配对，防止内存泄漏。<br>　　规则5：用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。***</p>
<h3 id="指针与数组的对比"><a href="#指针与数组的对比" class="headerlink" title="指针与数组的对比"></a>指针与数组的对比</h3><p>　　C++&#x2F;C程序中，指针和数组在不少地方可以相互替换着用，让人产生一种错觉，以为两者是等价的。<br>　　**数组：**要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。<br>　　**指针：**可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。
　　</p>
<blockquote>
<p>下面以字符串为例比较指针与数组的特性。</p>
</blockquote>
<ol>
<li><strong>修改内容</strong><br>　　下面示例中，字符数组a的容量是6个字符，其内容为 hello。a的内容可以改变，如a[0]&#x3D; ‘X’。指针p指向常量字符串“world”（位于静态存储区，内容为world），常量字符串的内容是不可以被修改的。从语法上看，编译器并不觉得语句p[0]&#x3D; ‘X’有什么不妥，但是该语句企图修改常量字符串的内容而导致运行错误。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[] = “hello”;</span><br><span class="line">a[<span class="number">0</span>] = ‘X’;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="type">char</span> *p = “world”; <span class="comment">// 注意p指向常量字符串</span></span><br><span class="line">p[<span class="number">0</span>] = ‘X’; <span class="comment">// 编译器不能发现该错误</span></span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>内容复制与比较</strong><br>　　不能对数组名进行直接复制与比较。若想把数组a的内容复制给数组b，不能用语句 b &#x3D; a ，否则将产生编译错误。应该用标准库函数strcpy进行复制。同理，比较b和a的内容是否相同，不能用if(b&#x3D;&#x3D;a) 来判断，应该用标准库函数strcmp进行比较。<br>　　语句 p &#x3D; a 并不能把a的内容复制给指针p，而是把a的地址赋给了p。要想复制a的内容，可以先用库函数malloc为p申请一块容量为strlen(a)+1个字符的内存，再用strcpy进行字符串复制。同理，语句if(p&#x3D;&#x3D;a) 比较的不是内容而是地址，应该用库函数strcmp来比较。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组…</span></span><br><span class="line"><span class="type">char</span> a[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> b[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(b, a); <span class="comment">// 不能用 b = a;</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(b, a) == <span class="number">0</span>) <span class="comment">// 不能用 if (b == a)</span></span><br><span class="line">…</span><br><span class="line"><span class="comment">// 指针…</span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(a);</span><br><span class="line"><span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>)*(len<span class="number">+1</span>));</span><br><span class="line"><span class="built_in">strcpy</span>(p,a); <span class="comment">// 不要用 p = a;</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(p, a) == <span class="number">0</span>) <span class="comment">// 不要用 if (p == a)</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>计算内存容量</strong><br>　　用运算符sizeof可以计算出数组的容量（字节数）。如下示例中，sizeof(a)的值是12。指针p指向a，但是sizeof(p)的值却是4。这是因为sizeof(p)得到的是一个指针变量的字节数，相当于sizeof(char*)，而不是p所指的内存容量。C++&#x2F;C语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p = a;</span><br><span class="line">cout&lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="comment">// 12字节</span></span><br><span class="line">cout&lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl; <span class="comment">// 4字节</span></span><br></pre></td></tr></table></figure>
<p>　　注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。如下示例中，不论数组a的容量是多少，sizeof(a)始终等于sizeof(char *)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">char</span> a[<span class="number">100</span>])</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="comment">// 4字节而不是100字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针参数是如何传递内存的"><a href="#指针参数是如何传递内存的" class="headerlink" title="指针参数是如何传递内存的"></a>指针参数是如何传递内存的</h3><p>　　如果函数的参数是一个指针，不要指望用该指针去申请动态内存。如下示例中，Test函数的语句GetMemory(str, 200)并没有使str获得期望的内存，str依旧是NULL，为什么？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetMemory</span><span class="params">(<span class="type">char</span> *p, <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">GetMemory</span>(str, <span class="number">100</span>); <span class="comment">// str 仍然为 NULL</span></span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>); <span class="comment">// 运行错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　毛病出在函数GetMemory中。编译器总是要为函数的每个参数制作临时副本，指针参数p的副本是 _p，编译器使 _p&#x3D;p。如果函数体内的程序修改了_p的内容，就导致参数p的内容作相应的修改。这就是指针可以用作输出参数的原因。在本例中，_p申请了新的内存，只是把 _p所指的内存地址改变了，但是p丝毫未变。所以函数GetMemory并不能输出任何东西。事实上，每执行一次GetMemory就会泄露一块内存，因为没有用free释放内存。<br>　　如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”，见示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetMemory2</span><span class="params">(<span class="type">char</span> **p, <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test2</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">GetMemory2</span>(&amp;str, <span class="number">100</span>); <span class="comment">// 注意参数是 &amp;str，而不是str</span></span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    cout&lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　由于“指向指针的指针”这个概念不容易理解，我们可以用函数返回值来传递动态内存。这种方法更加简单，见示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">GetMemory3</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * num);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test3</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = <span class="built_in">GetMemory3</span>(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    cout&lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　用函数返回值来传递动态内存这种方法虽然好用，但是常常有人把return语句用错了。这里强调不要用return语句返回指向“栈内存”的指针，因为该内存在函数结束时自动消亡，见示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">GetString</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> p[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// 编译器将提出警告</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test4</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = <span class="built_in">GetString</span>(); <span class="comment">// str 的内容是垃圾</span></span><br><span class="line">    cout&lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　用调试器逐步跟踪Test4，发现执行str &#x3D; GetString语句后str不再是NULL指针，但是str的内容不是“hello world”而是垃圾。<br>　　如果把上述示例改写成如下示例，会怎么样？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">GetString2</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test5</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = <span class="built_in">GetString2</span>();</span><br><span class="line">    cout&lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数Test5运行虽然不会出错，但是函数GetString2的设计概念却是错误的。因为GetString2内的“hello world”是常量字符串，位于静态存储区，它在程序生命期内恒定不变。无论什么时候调用GetString2，它返回的始终是同一个“只读”的内存块。</p>
<h3 id="杜绝“野指针”"><a href="#杜绝“野指针”" class="headerlink" title="杜绝“野指针”"></a>杜绝“野指针”</h3><p>　　“野指针”不是NULL指针，是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。 “野指针”的成因主要有三种：</p>
<ol>
<li><strong>指针变量没有被初始化</strong>。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">char</span> *str = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。</strong></li>
<li><strong>指针操作超越了变量的作用域范围。</strong> 这种情况让人防不胜防，示例程序如下：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">void</span>)</span></span>&#123; cout &lt;&lt; “Func of <span class="keyword">class</span> <span class="title class_">A</span>” &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    A *p;</span><br><span class="line">    A a; </span><br><span class="line">    p = &amp;a; <span class="comment">// 注意 a 的生命期</span></span><br><span class="line">    p-&gt;<span class="built_in">Func</span>(); <span class="comment">// p是“野指针”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数Test在执行语句p-&gt;Func()时，对象a已经消失，而p是指向a的，所以p就成了“野指针”。但奇怪的是我运行这个程序时居然没有出错，这可能与编译器有关。</p>
<h3 id="有了malloc-free为什么还要new-delete"><a href="#有了malloc-free为什么还要new-delete" class="headerlink" title="有了malloc&#x2F;free为什么还要new&#x2F;delete"></a>有了malloc&#x2F;free为什么还要new&#x2F;delete</h3><p>　　malloc与free是C++&#x2F;C语言的标准库函数，new&#x2F;delete是C++的运算符。它们都可用于申请动态内存和释放内存。<br>　　对于非内部数据类型的对象而言，光用maloc&#x2F;free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc&#x2F;free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc&#x2F;free。<br>　　因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new&#x2F;delete不是库函数。我们先看一看malloc&#x2F;free和new&#x2F;delete如何实现对象的动态内存管理，见示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">　　<span class="built_in">Obj</span>(<span class="type">void</span>)&#123; cout &lt;&lt; “Initialization” &lt;&lt; endl; &#125;</span><br><span class="line">　　~<span class="built_in">Obj</span>(<span class="type">void</span>)&#123; cout &lt;&lt; “Destroy” &lt;&lt; endl; &#125;</span><br><span class="line">　　<span class="function"><span class="type">void</span> <span class="title">Initialize</span><span class="params">(<span class="type">void</span>)</span></span>&#123; cout &lt;&lt; “Initialization” &lt;&lt; endl; &#125;</span><br><span class="line">　　<span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">(<span class="type">void</span>)</span></span>&#123; cout &lt;&lt; “Destroy” &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UseMallocFree</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    Obj *a = (obj *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(obj)); <span class="comment">// 申请动态内存</span></span><br><span class="line">    a-&gt;<span class="built_in">Initialize</span>(); <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">    a-&gt;<span class="built_in">Destroy</span>(); <span class="comment">// 清除工作</span></span><br><span class="line">    <span class="built_in">free</span>(a); <span class="comment">// 释放内存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UseNewDelete</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    Obj *a = <span class="keyword">new</span> Obj; <span class="comment">// 申请动态内存并且初始化</span></span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">    <span class="keyword">delete</span> a; <span class="comment">// 清除并且释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　类Obj的函数Initialize模拟了构造函数的功能，函数Destroy模拟了析构函数的功能。函数UseMallocFree中，由于malloc&#x2F;free不能执行构造函数与析构函数，必须调用成员函数Initialize和Destroy来完成初始化与清除工作。函数UseNewDelete则简单得多。<br>　　所以我们不要企图用malloc&#x2F;free来完成动态对象的内存管理，应该用new&#x2F;delete。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言malloc&#x2F;free和new&#x2F;delete是等价的。<br>　　既然new&#x2F;delete的功能完全覆盖了malloc&#x2F;free，为什么C++不把malloc&#x2F;free淘汰出局呢？这是因为C++程序经常要调用C函数，而C程序只能用malloc&#x2F;free管理动态内存。<br>　　如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，结果也会导致程序出错，但是该程序的可读性很差。所以new&#x2F;delete必须配对使用，malloc&#x2F;free也一样。</p>
<h3 id="内存耗尽怎么办"><a href="#内存耗尽怎么办" class="headerlink" title="内存耗尽怎么办"></a>内存耗尽怎么办</h3><p>　　如果在申请动态内存时找不到足够大的内存块，malloc和new将返回NULL指针，宣告内存申请失败。通常有三种方式处理“内存耗尽”问题。</p>
<ol>
<li><strong>判断指针是否为NULL，如果是则马上用return语句终止本函数。</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> A;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>判断指针是否为NULL，如果是则马上用exit(1)终止整个程序的运行。</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> A;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout &lt;&lt; “Memory Exhausted” &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>为new和malloc设置异常处理函数。</strong><br>　　Visual C++可以用_set_new_hander函数为new设置用户自己定义的异常处理函数，也可以让malloc享用与new相同的异常处理函数。详细内容请参考C++使用手册。<br>　　上述 1、2 方式使用最普遍。如果一个函数内有多处需要申请动态内存，那么方式 1 就显得力不从心（释放内存很麻烦），应该用方式 2 来处理。<br>　　很多人不忍心用exit(1)，问：“不编写出错处理程序，让操作系统自己解决行不行？”<br>　　不行。如果发生“内存耗尽”这样的事情，一般说来应用程序已经无药可救。如果不用exit(1) 把坏程序杀死，它可能会害死操作系统。道理如同：如果不把歹徒击毙，歹徒在老死之前会犯下更多的罪。<br>　　有一个很重要的现象要告诉大家。对于32位以上的应用程序而言，无论怎样使用malloc与new，几乎不可能导致“内存耗尽”。对于32位以上的应用程序，“内存耗尽”错误处理程序毫无用处。这下可把Unix和Windows程序员们乐坏了：反正错误处理程序不起作用，我就不写了，省了很多麻烦。</li>
</ol>
<blockquote>
<p>必须强调：不加错误处理将导致程序的质量很差，千万不可因小失大。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">float</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">float</span>[<span class="number">1000000</span>];</span><br><span class="line">        cout &lt;&lt; “eat memory” &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="malloc-free的使用要点"><a href="#malloc-free的使用要点" class="headerlink" title="malloc&#x2F;free的使用要点"></a>malloc&#x2F;free的使用要点</h3><p>函数malloc的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>　　用malloc申请一块长度为length的整数类型的内存，程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * length);</span><br></pre></td></tr></table></figure>
<p>　　我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”。<br>　　malloc返回值的类型是void *，所以在调用malloc时要显式地进行类型转换，将void *转换成所需要的指针类型。<br>　　malloc函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。我们通常记不住int, float等数据类型的变量的确切字节数。例如int变量在16位系统下是2个字节，在32位下是4个字节；而float变量在16位系统下是4个字节，在32位下也是4个字节。最好用以下程序作一次测试：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">void</span> *) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>　　在malloc的“()”中使用sizeof运算符是良好的风格，但要当心有时我们会昏了头，写出 p &#x3D; malloc(sizeof(p))这样的程序来。<br>　　函数free的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">( <span class="type">void</span> * memblock )</span></span>;</span><br></pre></td></tr></table></figure>
<p>　　为什么free函数不象malloc函数那样复杂呢？这是因为指针p的类型以及它所指的内存的容量事先都是知道的，语句free(p)能正确地释放内存。如果p是NULL指针，那么free对p无论操作多少次都不会出问题。如果p不是NULL指针，那么free对p连续操作两次就会导致程序运行错误。</p>
<h3 id="new-delete的使用要点"><a href="#new-delete的使用要点" class="headerlink" title="new&#x2F;delete的使用要点"></a>new&#x2F;delete的使用要点</h3><p>　　运算符new使用起来要比函数malloc简单得多，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * length);</span><br><span class="line"><span class="type">int</span> *p2 = <span class="keyword">new</span> <span class="type">int</span>[length];</span><br></pre></td></tr></table></figure>
<p>　　这是因为new内置了sizeof、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，new在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那么new的语句也可以有多种形式。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">    <span class="built_in">Obj</span>(<span class="type">void</span>); <span class="comment">// 无参数的构造函数</span></span><br><span class="line">    <span class="built_in">Obj</span>(<span class="type">int</span> x); <span class="comment">// 带一个参数的构造函数</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    Obj *a = <span class="keyword">new</span> Obj;</span><br><span class="line">    Obj *b = <span class="keyword">new</span> <span class="built_in">Obj</span>(<span class="number">1</span>); <span class="comment">// 初值为1</span></span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　如果用new创建对象数组，那么只能使用对象的无参数构造函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Obj *objects = <span class="keyword">new</span> Obj[<span class="number">100</span>]; <span class="comment">// 创建100个动态对象</span></span><br></pre></td></tr></table></figure>
<p>　　不能写成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Obj *objects = <span class="keyword">new</span> Obj[<span class="number">100</span>](<span class="number">1</span>);<span class="comment">// 创建100个动态对象的同时赋初值1</span></span><br></pre></td></tr></table></figure>
<p>　　在用delete释放对象数组时，留意不要丢了符号‘[]’。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> []objects; <span class="comment">// 正确的用法</span></span><br><span class="line"><span class="keyword">delete</span> objects; <span class="comment">// 错误的用法</span></span><br></pre></td></tr></table></figure>
<p>　　后者有可能引起程序崩溃和内存泄漏。</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2018 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Navy</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/lzxy169" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
