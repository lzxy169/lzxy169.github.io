<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Inconsolata:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.lzxy169.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":true,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="It is about walking the path and responding to the heart.">
<meta property="og:type" content="website">
<meta property="og:title" content="Navy&#39;s blog">
<meta property="og:url" content="https://blog.lzxy169.com/page/2/index.html">
<meta property="og:site_name" content="Navy&#39;s blog">
<meta property="og:description" content="It is about walking the path and responding to the heart.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Navy">
<meta property="article:tag" content="lzxy169, blog, navy">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.lzxy169.com/page/2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Navy's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/pjax.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/wavedrom.min.js","integrity":"sha256-INLAoJc6quTNfiMWkGZniYO2cxE8mHpddnLow1m6RFs="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js" defer></script>


  <script src="/js/third-party/pace.js" defer></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/3.0.1/quicklink.umd.js" integrity="sha256-44BednzIpUeQJcY8qtLyarFu0UCCTbgmWOvaoehiFQQ=" crossorigin="anonymous" defer></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":false,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://blog.lzxy169.com/page/2/"}</script>
  <script src="/js/third-party/quicklink.js" defer></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Navy's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Navy's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">2</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">4</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">9</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Navy"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Navy</p>
  <div class="site-description" itemprop="description">It is about walking the path and responding to the heart.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lzxy169" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lzxy169" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lzxy169@gmail.com" title="E-Mail → mailto:lzxy169@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.lzxy169.com/2018/04/12/algorithm-application/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Navy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Navy's blog">
      <meta itemprop="description" content="It is about walking the path and responding to the heart.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Navy's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/12/algorithm-application/" class="post-title-link" itemprop="url">算法之应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-12 12:25:58" itemprop="dateCreated datePublished" datetime="2018-04-12T12:25:58+08:00">2018-04-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-21 11:39:43" itemprop="dateModified" datetime="2025-11-21T11:39:43+08:00">2025-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="递归-Recursive"><a href="#递归-Recursive" class="headerlink" title="递归(Recursive)"></a>递归(Recursive)</h3><p>当一个函数用它自己来定义时就称为时递归。<br>阶乘、斐波那契数列和汉诺塔，帕斯卡三角形，也就是著名的杨辉三角</p>
<figure class="highlight c"><figcaption><span>// 递归</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">recursion_loop</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        recursion_loop(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用： recursion_loop(0);</span></span><br></pre></td></tr></table></figure>

<h3 id="取幂运算"><a href="#取幂运算" class="headerlink" title="取幂运算"></a>取幂运算</h3><p>计算x的N次方常见的算法是N-1次乘法自乘，递归的基准条件是：N&#x3D;&#x3D;0  此时返回1（不调用自身）。<br>若N是偶数，则x的N次方等于 x<em>x的N&#x2F;2次方。<br>若N是奇数，则x的N次方等于 x</em>x的N&#x2F;2次方在乘以x。<br>时间复杂度：O($\log_2 n$)</p>
<figure class="highlight c"><figcaption><span>// 取幂运算</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">pow</span><span class="params">(<span class="type">long</span> <span class="type">int</span> x, <span class="type">unsigned</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span> ((x &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123; <span class="comment">// 偶数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x * x, n / <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//        return pow(x * x, n / 2) * x;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x, n - <span class="number">1</span>) * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><p>0!&#x3D;1，n!&#x3D;(n-1)!×n</p>
<figure class="highlight c"><figcaption><span>// 阶乘</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">factorial</span><span class="params">(<span class="type">const</span> <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == n || <span class="number">1</span> == n ? <span class="number">1</span>  : n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="斐波那契数列-Fibonacci"><a href="#斐波那契数列-Fibonacci" class="headerlink" title="斐波那契数列(Fibonacci)"></a>斐波那契数列(Fibonacci)</h3><p>又称黄金分割数列,以递归的方法定义：F(0)&#x3D;0，F(1)&#x3D;1, F(n)&#x3D;F(n-1)+F(n-2)（n&gt;&#x3D;2，n∈N*）<br>1, 1, 2, 3, 5, 8, 13, 21, 34...这个数列从第3项开始，每一项都等于前两项之和。</p>
<figure class="highlight c"><figcaption><span>// Fibonacci</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">fib</span><span class="params">(<span class="type">const</span> <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == n || <span class="number">1</span> == n ? <span class="number">1</span> : fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><p>假设有n片，移动次数是f(n).显然f(1)&#x3D;1,f(2)&#x3D;3,f(3)&#x3D;7，且f(k+1)&#x3D;2<em>f(k)+1 (等比数列)。<br>证明(数学归纳法) f(n)&#x3D;$2^n$-1。<br>a(n) &#x3D; 2</em>a(n-1) + 1;<br>a(n) + 1 &#x3D; 2*(a(n-1) + 1);<br>于是{a(n)+1}是首项为a(1)&#x3D;1，公比为2的等比数列，<br>求得a(n)+1 &#x3D; $2^n$，所以a(n) &#x3D; $2^n$ - 1;</p>
<figure class="highlight c"><figcaption><span>// Fibonacci</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">const</span> <span class="type">char</span> x, <span class="type">const</span> <span class="type">int</span> n, <span class="type">const</span> <span class="type">char</span> z)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;把圆盘 %d 从柱子 %c 移动到 %c 上\n&quot;</span>, n, x, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n, <span class="type">const</span> <span class="type">char</span> x, <span class="type">const</span> <span class="type">char</span> y, <span class="type">const</span> <span class="type">char</span> z)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == n)</span><br><span class="line">        move(x, <span class="number">1</span>, z);          <span class="comment">// 如果只有一个盘，则直接将它从x移动到z</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        hanoi(n - <span class="number">1</span>, x, z, y);  <span class="comment">// 把1 ~ n - 1个盘从x移动到y，用z作为中转</span></span><br><span class="line">        move(x, n, z);           <span class="comment">// 把第n个盘从x移动到z</span></span><br><span class="line">        hanoi(n - <span class="number">1</span>, y, x, z);  <span class="comment">// 把1 ~ n - 1个盘从y移动到z，用x作为中转</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="帕斯卡三角形"><a href="#帕斯卡三角形" class="headerlink" title="帕斯卡三角形"></a>帕斯卡三角形</h3><p>也就是著名的杨辉三角:三角形边界上的数都是1，内部的每个数是位于它上面的两个数之和。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1    1</span><br><span class="line">1    2    1</span><br><span class="line">1    3    3    1</span><br><span class="line">1    4    6    4    1</span><br></pre></td></tr></table></figure>
<p>利用递归我们可以很容易地把问题转换为这个性质：<br>假设：f(row, col)表示杨辉三角的第row行的第col个元素，那么：</p>
<ol>
<li>f(row, col) &#x3D; 1 (col &#x3D; 1 或者 row &#x3D; col)，也就是递归的停止条件。</li>
<li>f(row, col) &#x3D; f(row - 1, col - 1) + f(row - 1, col)，也就是上一行的两个相邻元素的和。</li>
</ol>
<figure class="highlight c"><figcaption><span>// 帕斯卡三角形</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">GetElement</span><span class="params">(<span class="type">const</span> <span class="type">long</span> row, <span class="type">const</span> <span class="type">long</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">1</span> == col) || (row == col)) <span class="comment">// 每行的外围两个元素为1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 其余的部分为上一行的(col - 1)和(col)元素之和</span></span><br><span class="line">        <span class="keyword">return</span> GetElement(row - <span class="number">1</span>, col - <span class="number">1</span>) + GetElement(row - <span class="number">1</span>, col);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求两个整数的最大公约数"><a href="#求两个整数的最大公约数" class="headerlink" title="求两个整数的最大公约数"></a>求两个整数的最大公约数</h3><p>最大公约数:几个整数中公有的约数，叫做这几个数的公约数；其中最大的一个，叫做这几个数的最大公约数。<br>最小公倍数:公倍数(common multiple)指在两个或两个以上的自然数中，如果它们有相同的倍数，这些倍数就是它们的公倍数，其中除0以外最小的一个公倍数，叫做这几个数的最小公倍数。<br>两个数的乘积等于两个数的最大公约数和最小公倍数的乘积。</p>
<p>最大公约数：同时整除两个整数的最大整数。<br>最小公倍数 &#x3D; (a * b)&#x2F;最大公约数。</p>
<p>如果N整除A-B，那么我们就说A与B模N同余。</p>
<figure class="highlight c"><figcaption><span>// 最大公约数</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.直接遍历法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxCommonDivisor</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=b; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span> &amp;&amp; b % i == <span class="number">0</span>) &#123;</span><br><span class="line">            max = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.辗转相除法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxCommonDivisor</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">while</span>(a % b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        r = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.欧几里得算法计算最大公约数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rem;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        rem = m % n;</span><br><span class="line">        m = n;</span><br><span class="line">        n = rem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不用中间变量-用两种方法交换A和B的值"><a href="#不用中间变量-用两种方法交换A和B的值" class="headerlink" title="不用中间变量,用两种方法交换A和B的值"></a>不用中间变量,用两种方法交换A和B的值</h3><figure class="highlight c"><figcaption><span>// 交换</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.中间变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">   <span class="type">int</span> temp = a;</span><br><span class="line">   a = b;</span><br><span class="line">   b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.加法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">   a = a + b;</span><br><span class="line">   b = a - b;</span><br><span class="line">   a = a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.异或（相同为0，不同为1. 可以理解为不进位加法）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">   a = a ^ b;</span><br><span class="line">   b = a ^ b;</span><br><span class="line">   a = a ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现一个字符串“how-are-you”的逆序输出"><a href="#实现一个字符串“how-are-you”的逆序输出" class="headerlink" title="实现一个字符串“how are you”的逆序输出"></a>实现一个字符串“how are you”的逆序输出</h3><p>如给定字符串为“hello world”,输出结果应当为“world hello”。</p>
<figure class="highlight c"><figcaption><span>// 逆序</span></figcaption><table><tr><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="title function_">spliterFunc</span><span class="params">(<span class="type">char</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c[i][j] = *p;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = i; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, c[k]);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置"><a href="#给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置" class="headerlink" title="给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置"></a>给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置</h3><p>如“abaccddeeef”,字符是b,输出应该是2。</p>
<figure class="highlight c"><figcaption><span>// 输出字符串</span></figcaption><table><tr><td class="code"><pre><span class="line"> <span class="type">char</span> *<span class="title function_">strOutPut</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">compareDifferentChar</span><span class="params">(<span class="type">char</span>, <span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *inputStr = <span class="string">&quot;abaccddeeef&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *outputStr = strOutPut(inputStr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c \n&quot;</span>, *outputStr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strOutPut</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> *p = s;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*s != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareDifferentChar(*s, p) == <span class="number">1</span>) &#123;</span><br><span class="line">            str[index] = *s;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareDifferentChar</span><span class="params">(<span class="type">char</span> c, <span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*s != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; i&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s == c) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p>二叉树的先序遍历为FBACDEGH,中序遍历为：ABDCEFGH,请写出这个二叉树的后序遍历结果。<br>ADECBHGF</p>
<p><img src="/images/post/algorithm-application/WechatIMG2.jpeg" loading="lazy"></p>
<p>先序遍历：++a<em>bc</em>+*defg :<br>根-----&gt;左——&gt;右 :先访问根节点，前序遍历左子树，再前序遍历右子树。（简记为：VLR）</p>
<p>中序遍历：(a+b<em>c)+((d</em>e+f)*g) :<br>左-----&gt;根-----&gt;右 :从根节点开始，中序遍历根节点的左子树，然后访问根节点，最后中序遍历右子树。（简记为：LVR）</p>
<p>后序遍历：abc*+de<em>f+g</em>+ :<br>左-----&gt;右-----&gt;根 :从左到右先叶子后节点的方式遍历访问左右子树，左右子树都访问结束，才访问根节点。（简称LRV）</p>
<p>层序遍历：++<em>a</em>+gbc*fde :<br>左---&gt;右  上---&gt;下</p>
<p><img src="/images/post/algorithm-application/WechatIMG3.jpeg" loading="lazy"><br>先序+中序遍历还原二叉树：先序遍历是：ABDEGCFH 中序遍历是：DBGEACHF<br>首先从先序得到第一个为A，就是二叉树的根，回到中序，可以将其分为三部分：<br>左子树的中序序列DBGE，根A，右子树的中序序列CHF<br>接着将左子树的序列回到先序可以得到B为根，这样回到左子树的中序再次将左子树分割为三部分：<br>左子树的左子树D，左子树的根B，左子树的右子树GE<br>同样地，可以得到右子树的根为C<br>类似地将右子树分割为根C，右子树的右子树HF，注意其左子树为空<br>如果只有一个就是叶子不用再进行了，刚才的GE和HF再次这样运作，就可以将二叉树还原了。<br>后序遍历：DGEBHFCA</p>
<h3 id="打印2-100之间的素数-质数"><a href="#打印2-100之间的素数-质数" class="headerlink" title="打印2-100之间的素数(质数)"></a>打印2-100之间的素数(质数)</h3><p>质数又称素数。一个大于1的自然数，除了1和它自身外，不能整除其他自然数的数叫做质数；否则称为合数。<br>在一般领域，对正整数n，如果用 2 到 $\sqrt n$ 之间的所有整数去除，均无法整除，则n为质数。</p>
<figure class="highlight c"><figcaption><span>// 素数</span></figcaption><table><tr><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> r = isPrime(i);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%ld &quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, s;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++)</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="给一列无序数组，求出中位数并给出算法的时间复杂度。"><a href="#给一列无序数组，求出中位数并给出算法的时间复杂度。" class="headerlink" title="给一列无序数组，求出中位数并给出算法的时间复杂度。"></a>给一列无序数组，求出中位数并给出算法的时间复杂度。</h3><p>若数组有奇数个元素，中位数是a[(n-1)&#x2F;2]；<br>若数组有偶数个元素，中位数为a[n&#x2F;2-1]和a[n&#x2F;2]两个数的平均值。<br>这里为方便起见，假设数组为奇数个元素。</p>
<p>**思路一：**把无序数组排好序，取出中间的元素。<br>时间复杂度取决于排序算法，最快是快速排序，O(n$\log_2 n$)，或者是非比较的基数排序，时间为O(n),空间为O(n)。这明显不是我们想要的。</p>
<p>**思路二：**采用快速排序的分治partition过程。<br>任意挑一个元素，以该元素为支点，将数组分成两部分，左边是小于等于支点的，右边是大于支点的。<br>如果左侧长度正好是(n - 1)&#x2F;2，那么支点恰为中位数。<br>如果左侧长度&lt;(n-1)&#x2F;2, 那么中位数在右侧，反之，中位数在左侧，进入相应的一侧继续寻找中位数。</p>
<figure class="highlight c"><figcaption><span>// 快速排序的分治过程找无序数组的中位数</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> low, <span class="type">int</span> high)</span>  &#123; <span class="comment">// 快排的一次排序过程</span></span><br><span class="line">    <span class="type">int</span> q = a[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; a[high] &gt;= q)</span><br><span class="line">            high--;</span><br><span class="line">        a[low] = a[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; a[low] &lt;= q)</span><br><span class="line">            low++;</span><br><span class="line">        a[high] = a[low];</span><br><span class="line">    &#125;</span><br><span class="line">    a[low] = q;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findMidium</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = n / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> q = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index != q) &#123;</span><br><span class="line">        q = partition(a, left, right);</span><br><span class="line">        <span class="keyword">if</span> (q &lt; index)</span><br><span class="line">            left = q + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q&gt;index)</span><br><span class="line">            right = q - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**思路三：**将数组的前(n+1)&#x2F;2个元素建立一个最小堆。<br>然后，对于下一个元素，和堆顶的元素比较，如果小于等于，丢弃之，如果大于，则用该元素取代堆顶，再调整堆，接着看下一个元素。<br>重复这个步骤，直到数组为空。当数组都遍历完了，(堆中元素为最大的(n+1)&#x2F;2个元素) 堆顶的元素即是中位数。</p>
<figure class="highlight c"><figcaption><span>// 构建最小堆找无序数组的中位数</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nswap</span><span class="params">(<span class="type">int</span>&amp; i, <span class="type">int</span>&amp; j)</span> &#123;</span><br><span class="line">    i = i^j;</span><br><span class="line">    j = i^j;</span><br><span class="line">    i = i^j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">minHeapify</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> least = i; <span class="comment">// 根节点,最小的</span></span><br><span class="line">    <span class="type">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> r = i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; len &amp;&amp; a[l] &lt; a[least])</span><br><span class="line">        least = l;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; len &amp;&amp; a[r] &lt; a[least])</span><br><span class="line">        least = r;</span><br><span class="line">    <span class="keyword">if</span> (least != i) &#123;</span><br><span class="line">        nswap(a[i], a[least]);</span><br><span class="line">        minHeapify(a, least, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMinHeap</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="comment">// len/2-1 或者 (len-2) / 2, 为最后一个非叶子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (len<span class="number">-2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        minHeapify(a, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findMidium2</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    buildMinHeap(a, (n + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (n + <span class="number">1</span>) / <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; a[<span class="number">0</span>]) &#123;</span><br><span class="line">            nswap(a[i], a[<span class="number">0</span>]);</span><br><span class="line">            minHeapify(a, <span class="number">0</span>,(n + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>引申一：查找N个元素中的第K个小的元素</strong><br>编程珠玑给出了一个时间复杂度O(N)的解决方案。该方案改编自快速排序。<br>经过快排的一次划分，<br>   1）如果左半部份的长度&gt;K-1，那么这个元素就肯定在左半部份了<br>   2）如果左半部份的长度&#x3D;&#x3D;K-1，那么当前划分元素就是结果了。<br>   3）如果。。。。。。。&lt;K-1,那么这个元素就肯定在右半部分了。<br>并且，该方法可以用尾递归实现。效率更高。<br>也可以用来查找N个元素中的前K个小的元素，前K个大的元素。。。。等等。</p>
<p><strong>引申二：查找N个元素中的第K个小的元素，假设内存受限，仅能容下K&#x2F;4个元素。</strong><br>分趟查找，<br>第一趟，用堆方法查找最小的K&#x2F;4个小的元素，同时记录剩下的N-K&#x2F;4个元素到外部文件。<br>第二趟，用堆方法从第一趟筛选出的N-K&#x2F;4个元素中查找K&#x2F;4个小的元素，同时记录剩下的N-K&#x2F;2个元素到外部文件。<br>。。。<br>第四趟，用堆方法从第一趟筛选出的N-K&#x2F;3个元素中查找K&#x2F;4个小的元素，这是的第K&#x2F;4小的元素即使所求。</p>
<h3 id="输入一个整型数组，求出子数组和的最大值，并给出算法的时间复杂度。"><a href="#输入一个整型数组，求出子数组和的最大值，并给出算法的时间复杂度。" class="headerlink" title="输入一个整型数组，求出子数组和的最大值，并给出算法的时间复杂度。"></a>输入一个整型数组，求出子数组和的最大值，并给出算法的时间复杂度。</h3><p>假如只有两个数，a[0] and a[1]。<br>这样，最大值存在的情况，无非就是：a[0], a[0] + a[1], a[1]。这个过程基本就是三个数字中，找到最大值的过程。</p>
<p>然后推广到n的时候，从0-&gt;n - 1遍历只要重复这个过程，就能简单的获取到最终的最大值。</p>
<p>假设现在有三个数字a[0] a[1] a[2].<br>这样先比较前两个元素，a[0],a[1],以及a[0] + a[1]。因为下次的比较需要将前面的a[0]+a[1]作为一个整体加入到下一次的比较中，所以需要有一个值能够用来表示其和。这个变量用nStart表示。<br>nAll则是相当于每次比较中的a[0]。那么每次的比较的顺序就是：a[1]和a[0] + a[1]比较。nStart取其最大值，然后在和相当于a[0]的nAll比较。如此往复，当线性遍历结束的时候，就成功的获取到了最大值。</p>
<p>时间复杂度O(n)，空间复杂度为O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define max(a, b) (a)&gt;(b)?(a):(b)</span><br><span class="line"></span><br><span class="line">int MaxSubArray(int *a, int n) &#123;</span><br><span class="line">    int nStart = a[0];</span><br><span class="line">    int nAll = a[0];</span><br><span class="line">    for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        nStart = max(a[i], nStart + a[i]);</span><br><span class="line">        nAll = max(nStart, nAll);</span><br><span class="line">    &#125;</span><br><span class="line">    return nAll;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl;</span><br><span class="line">    int array[] = &#123;10, -1, 3, -11, -20, 33, 1, -6, 13&#125;;</span><br><span class="line">    cout &lt;&lt; MaxSubArray(array, sizeof(array)/sizeof(int)) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.lzxy169.com/2018/04/10/algorithm-search/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Navy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Navy's blog">
      <meta itemprop="description" content="It is about walking the path and responding to the heart.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Navy's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/10/algorithm-search/" class="post-title-link" itemprop="url">算法之查找</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-10 12:25:58" itemprop="dateCreated datePublished" datetime="2018-04-10T12:25:58+08:00">2018-04-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2018-07-31 13:14:25" itemprop="dateModified" datetime="2018-07-31T13:14:25+08:00">2018-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1. 顺序查找"></a>1. 顺序查找</h3><p><strong>说明：</strong><br>顺序查找适合于存储结构为顺序存储或链接存储的线性表。</p>
<p><strong>基本思想：</strong><br>顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</p>
<p><strong>复杂度分析：</strong><br>查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL &#x3D; 1&#x2F;n(1+2+3+…+n) &#x3D; (n+1)&#x2F;2 ;<br>当查找不成功时，需要n+1次比较，时间复杂度为O(n); 所以，顺序查找的时间复杂度为O(n)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//顺序查找</span><br><span class="line">int SequenceSearch(int a[], int value, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0; i&lt;n; i++)</span><br><span class="line">        if(a[i]==value)</span><br><span class="line">            return i;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h3><p><strong>说明：</strong><br>元素必须是有序的，如果是无序的则要先进行排序操作。</p>
<p><strong>基本思想：</strong><br>也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。</p>
<p><strong>复杂度分析：</strong><br>最坏情况下，关键词比较次数为$\log_2 (n+1)$，且期望时间复杂度为O($\log_2 n$)；<br>注：折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//二分查找（折半查找），版本1</span><br><span class="line">int BinarySearch1(int a[], int value, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int low, high, mid;</span><br><span class="line">    low = 0;</span><br><span class="line">    high = n-1;</span><br><span class="line">    while(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low+high)/2;</span><br><span class="line">        if(a[mid]==value)</span><br><span class="line">            return mid;</span><br><span class="line">        if(a[mid]&gt;value)</span><br><span class="line">            high = mid-1;</span><br><span class="line">        if(a[mid]&lt;value)</span><br><span class="line">            low = mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//二分查找，递归版本</span><br><span class="line">int BinarySearch2(int a[], int value, int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">    int mid = low+(high-low)/2;</span><br><span class="line">    if(a[mid]==value)</span><br><span class="line">        return mid;</span><br><span class="line">    if(a[mid]&gt;value)</span><br><span class="line">        return BinarySearch2(a, value, low, mid-1);</span><br><span class="line">    if(a[mid]&lt;value)</span><br><span class="line">        return BinarySearch2(a, value, mid+1, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-插值查找"><a href="#3-插值查找" class="headerlink" title="3. 插值查找"></a>3. 插值查找</h3><p><strong>说明：</strong><br>在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是一定目的的往前或往后翻。同样的，比如要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5，我们自然会考虑从数组下标较小的开始查找。经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：mid&#x3D;(low+high)&#x2F;2, 即mid&#x3D;low+1&#x2F;2*(high-low);通过类比，我们可以将查找的点改进为如下：mid&#x3D;low+(key-a[low])&#x2F;(a[high]-a[low])*(high-low)也就是将上述的比例参数1&#x2F;2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。</p>
<p><strong>基本思想：</strong><br>基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。<br>注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</p>
<p><strong>复杂度分析：</strong><br>查找成功或者失败的时间复杂度均为O($\log_2 (log_2 n)$)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//插值查找</span><br><span class="line">int InsertionSearch(int a[], int value, int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">    int mid = low+(value-a[low])/(a[high]-a[low])*(high-low);</span><br><span class="line">    if(a[mid]==value)</span><br><span class="line">        return mid;</span><br><span class="line">    if(a[mid]&gt;value)</span><br><span class="line">        return InsertionSearch(a, value, low, mid-1);</span><br><span class="line">    if(a[mid]&lt;value)</span><br><span class="line">        return InsertionSearch(a, value, mid+1, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-斐波那契查找"><a href="#4-斐波那契查找" class="headerlink" title="4. 斐波那契查找"></a>4. 斐波那契查找</h3><p><strong>说明：</strong><br>在介绍斐波那契查找算法之前，我们先介绍一下很它紧密相连并且大家都熟知的一个概念——黄金分割。黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。</p>
<p>斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。<br>在数学上，斐波纳契数列以如下被以递归的方法定义：F(1)&#x3D;1，F(2)&#x3D;1, F(n)&#x3D;F(n-1)+F(n-2)（n&gt;&#x3D;2，n∈N*）然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。</p>
<p><strong>基本思想：</strong><br>也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。<br>相对于折半查找，一般将待比较的key值与第mid&#x3D;（low+high）&#x2F;2位置的元素比较，比较结果分三种情况：<br>1）相等，mid位置的元素即为所求<br>2）&gt;，low&#x3D;mid+1;<br>3）&lt;，high&#x3D;mid-1。<br>斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小1，及n&#x3D;F(k)-1;<br>开始将k值与第F(k-1)位置的记录进行比较(及mid&#x3D;low+F(k-1)-1),比较结果也分为三种<br>1）相等，mid位置的元素即为所求<br>2）&gt;，low&#x3D;mid+1,k-&#x3D;2;<br>说明：low&#x3D;mid+1说明待查找的元素在[mid+1,high]范围内，k-&#x3D;2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))&#x3D; Fk-1-F(k-1)&#x3D;Fk-F(k-1)-1&#x3D;F(k-2)-1个，所以可以递归的应用斐波那契查找。<br>3）&lt;，high&#x3D;mid-1,k-&#x3D;1。<br>说明：low&#x3D;mid+1说明待查找的元素在[low,mid-1]范围内，k-&#x3D;1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归 的应用斐波那契查找。</p>
<p><strong>复杂度分析：</strong><br>最坏情况下，时间复杂度为O($\log_2 n$)，且其期望复杂度也为O($\log_2 n$)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 斐波那契查找.cpp </span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include  &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int max_size=20;//斐波那契数组的长度</span><br><span class="line"></span><br><span class="line">/*构造一个斐波那契数组*/ </span><br><span class="line">void Fibonacci(int * F)</span><br><span class="line">&#123;</span><br><span class="line">    F[0]=0;</span><br><span class="line">    F[1]=1;</span><br><span class="line">    for(int i=2; i&lt;max_size; ++i)</span><br><span class="line">        F[i]=F[i-1]+F[i-2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*定义斐波那契查找法*/  </span><br><span class="line">int FibonacciSearch(int *a, int n, int key)  //a为要查找的数组,n为要查找的数组长度,key为要查找的关键字</span><br><span class="line">&#123;</span><br><span class="line">  int low=0;</span><br><span class="line">  int high=n-1;</span><br><span class="line">  </span><br><span class="line">  int F[max_size];</span><br><span class="line">  Fibonacci(F);//构造一个斐波那契数组F </span><br><span class="line"></span><br><span class="line">  int k=0;</span><br><span class="line">  while(n&gt;F[k]-1)//计算n位于斐波那契数列的位置</span><br><span class="line">      ++k;</span><br><span class="line"></span><br><span class="line">  int  * temp;//将数组a扩展到F[k]-1的长度</span><br><span class="line">  temp=new int [F[k]-1];</span><br><span class="line">  memcpy(temp,a,n*sizeof(int));</span><br><span class="line"></span><br><span class="line">  for(int i=n;i&lt;F[k]-1;++i)</span><br><span class="line">     temp[i]=a[n-1];</span><br><span class="line">  </span><br><span class="line">  while(low&lt;=high)</span><br><span class="line">  &#123;</span><br><span class="line">    int mid=low+F[k-1]-1;</span><br><span class="line">    if(key&lt;temp[mid])</span><br><span class="line">    &#123;</span><br><span class="line">      high=mid-1;</span><br><span class="line">      k-=1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(key&gt;temp[mid])</span><br><span class="line">    &#123;</span><br><span class="line">     low=mid+1;</span><br><span class="line">     k-=2;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">       if(mid&lt;n)</span><br><span class="line">           return mid; //若相等则说明mid即为查找到的位置</span><br><span class="line">       else</span><br><span class="line">           return n-1; //若mid&gt;=n则说明是扩展的数值,返回n-1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  delete [] temp;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[] = &#123;0,16,24,35,47,59,62,73,88,99&#125;;</span><br><span class="line">    int key=100;</span><br><span class="line">    int index=FibonacciSearch(a,sizeof(a)/sizeof(int),key);</span><br><span class="line">    cout&lt;&lt;key&lt;&lt;&quot; is located at:&quot;&lt;&lt;index;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-树表查找"><a href="#5-树表查找" class="headerlink" title="5. 树表查找"></a>5. 树表查找</h3><p><strong>说明：</strong><br><strong>5.1 最简单的树表查找算法——二叉树查找算法。</strong></p>
<p><strong>基本思想：</strong><br>二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。<br>二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树：<br>　　1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>　　2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>　　3）任意节点的左、右子树也分别为二叉查找树。<br>二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。<br>有关二叉查找树的查找、插入、删除等操作的详细讲解，请移步浅谈算法和数据结构:  <a target="_blank" rel="noopener" href="http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html">二叉查找树</a></p>
<p><strong>复杂度分析：</strong><br>它和二分查找一样，插入和查找的时间复杂度均为O($\log_2 n$)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。<br>基于二叉查找树进行优化，进而可以得到其他的树表查找算法，如平衡树、红黑树等高效算法。</p>
<p><strong>5.2 平衡查找树之2-3查找树（2-3 Tree）</strong><br>　　2-3查找树定义：和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下：<br>　　1）要么为空，要么：<br>　　2）对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。<br>　　3）对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。</p>
<p><strong>2-3查找树的性质：</strong><br>　　1）如果中序遍历2-3查找树，就可以得到排好序的序列；<br>　　2）在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。（这也是平衡树中“平衡”一词的概念，根节点到叶节点的最长距离对应于查找算法的最坏情况，而平衡树中根节点到叶节点的距离都一样，最坏情况也具有对数复杂度。）<br><strong>复杂度分析：</strong><br>2-3树的查找效率与树的高度是息息相关的。</p>
<ul>
<li>在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN</li>
<li>在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN, 距离来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。对于插入来说，只需要常数次操作即可完成，因为他只需要修改与该节点关联的节点即可，不需要检查其他节点，所以效率和查找类似。下面是2-3查找树的效率：</li>
</ul>
<p><strong>5.3 平衡查找树之红黑树（Red-Black Tree）</strong><br>　　2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgn，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，于是就有了一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）。</p>
<p><strong>基本思想：</strong><br>红黑树的思想就是对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。</p>
<p><strong>红黑树的定义：</strong><br>红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：</p>
<ul>
<li>红色节点向左倾斜</li>
<li>一个节点不可能有两个红色链接</li>
<li>整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。<br>　　下图可以看到红黑树其实是2-3树的另外一种表现形式：如果我们将红色的连线水平绘制，那么他链接的两个2-node节点就是2-3树中的一个3-node节点了。<br>**红黑树的性质：**整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同（2-3树的第2）性质，从根节点到叶子节点的距离都相等）。<br>**复杂度分析：**最坏的情况就是，红黑树中除了最左侧路径全部是由3-node节点组成，即红黑相间的路径长度是全黑路径长度的2倍。红黑树的平均高度大约为logn。<br>红黑树这种数据结构应用十分广泛，在多种编程语言中被用作符号表的实现，如：</li>
<li>Java中的java.util.TreeMap,java.util.TreeSet；</li>
<li>C++ STL中的：map,multimap,multiset；</li>
<li>.NET中的：SortedDictionary,SortedSet 等。</li>
</ul>
<p><strong>5.4 B树和B+树（B Tree&#x2F;B+ Tree）</strong><br>平衡查找树中的2-3树以及其实现红黑树。2-3树种，一个节点最多有2个key，而红黑树则使用染色的方式来标识这两个key。<br>维基百科对B树的定义为“在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。</p>
<p><strong>B树定义：</strong><br>B树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。</p>
<ul>
<li>根节点至少有两个子节点</li>
<li>每个节点有M-1个key，并且以升序排列</li>
<li>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间</li>
<li>其它节点至少有M&#x2F;2个子节点<br>可以看到B树是2-3树的一种扩展，他允许一个节点有多于2个的元素。B树的插入及平衡化操作和2-3树很相似</li>
</ul>
<p><strong>B+树定义：</strong><br>B+树是对B树的一种变形树，它与B树的差异在于：</p>
<ul>
<li>有k个子结点的结点必然有k个关键码；</li>
<li>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。</li>
<li>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</li>
</ul>
<p><strong>B和B+树的区别</strong><br>B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。<br><strong>B+ 树的优点在于：</strong></p>
<ul>
<li>由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。</li>
<li>B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。<br>但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。</li>
</ul>
<p>B&#x2F;B+树常用于文件系统和数据库系统中，它通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。它广泛用于文件系统及数据库中，如：</p>
<ul>
<li>Windows：HPFS文件系统；</li>
<li>Mac：HFS，HFS+文件系统；</li>
<li>Linux：ResiserFS，XFS，Ext3FS，JFS文件系统；</li>
<li>数据库：ORACLE，MYSQL，SQLSERVER等中。<br>有关B&#x2F;B+树在数据库索引中的应用，请看<a target="_blank" rel="noopener" href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">张洋的MySQL索引背后的数据结构及算法原理</a>这篇文章，这篇文章对MySQL中的如何使用B+树进行索引有比较详细的介绍，推荐阅读。</li>
</ul>
<p><strong>树表查找总结：</strong><br>二叉查找树平均查找性能不错，为O(logn)，但是最坏情况会退化为O(n)。在二叉查找树的基础上进行优化，我们可以使用平衡查找树。平衡查找树中的2-3查找树，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。<br>除此之外，2-3查找树的另一个扩展——B&#x2F;B+平衡树，在文件系统和数据库系统中有着广泛的应用。</p>
<h3 id="6-分块查找"><a href="#6-分块查找" class="headerlink" title="6. 分块查找"></a>6. 分块查找</h3><p><strong>说明：</strong><br>分块查找又称索引顺序查找，它是顺序查找的一种改进方法。</p>
<p><strong>基本思想：</strong><br>将n个数据元素&quot;按块有序&quot;划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须&quot;按块有序&quot;；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，</p>
<p><strong>复杂度分析：</strong><br><strong>算法流程：</strong><br>　　step1 先选取各块中的最大关键字构成一个索引表；<br>　　step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。</p>
<h3 id="7-哈希查找"><a href="#7-哈希查找" class="headerlink" title="7. 哈希查找"></a>7. 哈希查找</h3><p><strong>说明：</strong><br><strong>什么是哈希表（Hash）？</strong><br>　　我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素&quot;分类&quot;，然后将这个元素存储在相应&quot;类&quot;所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了&quot;冲突&quot;，换句话说，就是把不同的元素分在了相同的&quot;类&quot;之中。后面我们将看到一种解决&quot;冲突&quot;的简便做法。<br>　　总的来说，&quot;直接定址&quot;与&quot;解决冲突&quot;是哈希表的两大特点。<br><strong>什么是哈希函数？</strong><br>　　哈希函数的规则是：通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。</p>
<p><strong>基本思想：</strong><br>哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。</p>
<p><strong>算法流程：</strong><br>1）用给定的哈希函数构造哈希表；<br>2）根据选择的冲突处理方法解决地址冲突；常见的解决冲突的方法：拉链法和线性探测法。详细的介绍可以参见：浅谈算法和数据结构: 十一 哈希表。<br>3）在哈希表的基础上执行哈希查找。哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。</p>
<p><strong>复杂度分析：</strong><br>单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。</p>
<p><strong>使用Hash，我们付出了什么？</strong><br>　　我们在实际编程中存储一个大规模的数据，最先想到的存储结构可能就是map，也就是我们常说的KV pair，经常使用Python的博友可能更有这种体会。使用map的好处就是，我们在后续处理数据处理时，可以根据数据的key快速的查找到对应的value值。map的本质就是Hash表，那我们在获取了超高查找效率的基础上，我们付出了什么？<br>　　Hash是一种典型以空间换时间的算法，比如原来一个长度为100的数组，对其查找，只需要遍历且匹配相应记录即可，从空间复杂度上来看，假如数组存储的是byte类型数据，那么该数组占用100byte空间。现在我们采用Hash算法，我们前面说的Hash必须有一个规则，约束键与存储位置的关系，那么就需要一个固定长度的hash表，此时，仍然是100byte的数组，假设我们需要的100byte用来记录键与位置的关系，那么总的空间为200byte,而且用于记录规则的表大小会根据规则，大小可能是不定的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.lzxy169.com/2018/04/09/algorithm-sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Navy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Navy's blog">
      <meta itemprop="description" content="It is about walking the path and responding to the heart.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Navy's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/09/algorithm-sort/" class="post-title-link" itemprop="url">算法之排序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-09 12:25:58" itemprop="dateCreated datePublished" datetime="2018-04-09T12:25:58+08:00">2018-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-21 11:40:48" itemprop="dateModified" datetime="2025-11-21T11:40:48+08:00">2025-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>排序分为内部排序和外部排序，内部排序指待排序的记录在内存中，外部排序的记录数量很大，以至于内存放不下而放在外存中，排序过程需要访问外存。这里仅介绍内部排序，包括插入排序、交换排序、选择排序、归并排序、基数排序。</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>**1，直接插入排序：**就是检查第i个数字，如果在它的左边的数字比它大，进行交换，这个动作一直继续下去，直到这个数字的左边数字比它还要小，就可以停止了。插入排序法主要的回圈有两个变数：i和j，每一次执行这个回圈，就会将第i个数字放到左边恰当的位置去。<br>时间复杂度：O($n^2$)<br><img src="/images/post/algorithm-sort/insertSort.png" loading="lazy"></p>
<figure class="highlight c"><figcaption><span>// 直接插入 从小到大排序</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = a[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((a[j] &gt; tmp) &amp;&amp; (j &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">            a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><figcaption><span>// 直接插入</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">           <span class="type">int</span> tmp = a[i];</span><br><span class="line">           <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; tmp; j--) &#123;</span><br><span class="line">               a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">           &#125;</span><br><span class="line">           a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>**2，折半插入排序（binary insertion sort）：**当直接插入进行到某一趟时，对于a[i]来讲，前面i－1个记录已经按关键字有序。此时不用直接插入排序的方法，而改为折半查找，找出a[i]应插入的位置。<br>时间复杂度：O($n^2$)</p>
<figure class="highlight c"><figcaption><span>// 折半插入 从小到大排序</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">binaryInsertSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = a[i];</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> middle = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (tmp &lt; a[middle]) &#123;</span><br><span class="line">                high = middle - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">-1</span>; j &gt;= low; j--) &#123;</span><br><span class="line">            a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[low] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3，希尔排序：</strong>“缩小增量”的排序方法，初期选用增量较大间隔比较，然后增量缩小，最后为1，希尔排序对增量序列没有严格规定。<br>时间复杂度：O($n^(1.3)$)</p>
<figure class="highlight c"><figcaption><span>// 希尔排序 从小到大排序</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> k = n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = a[i];</span><br><span class="line">            <span class="type">int</span> j = i - k;</span><br><span class="line">            <span class="keyword">while</span> ((a[j] &gt; tmp) &amp;&amp; (j &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">                a[j+k] = a[j];</span><br><span class="line">                j -= k;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+k] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><p>**1，冒泡排序：**面对一排数据，先从前往后两两比较，如果前一个数比后一个数大就交换两者的顺序，即第一个数和第二个数比，第二个数和第三个数比，……,倒数第二个数和最后一个数比，这样一轮下来以后最大的数就排到最后；接着把除去最大的数的该组数据进行同样的操作，直至这组数只剩下一个，排序结束。<br>时间复杂度：O($n^2$)</p>
<figure class="highlight c"><figcaption><span>// 冒泡排序</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> a[] , <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++) &#123; <span class="comment">// 比较两个相邻的元素</span></span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> t = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**2，快速排序：**选取一个基准元素(通常已需要排序的数组第一个数)，然后通过一趟排序将比基准数大的放在右边，比基准数小的放在左边，接着对划分好的两个数组再进行上述的排序。快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。<br>时间复杂度：O(n$\log_2 n$)</p>
<p>挖坑填数进行总结<br>1)．i &#x3D; left;   j &#x3D; right; 将基准数挖出形成第一个坑a[i]。<br>2)．j- -由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。<br>3)．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。<br>4)．再重复执行2，3二步，直到i&#x3D;&#x3D;j，将基准数填入a[i]中。</p>
<figure class="highlight c"><figcaption><span>// 快速排序</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) &#123; <span class="comment">// 如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="type">int</span> j = right;</span><br><span class="line">    <span class="type">int</span> key = a[left];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123; <span class="comment">// 控制在当前组内寻找一遍</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &lt;= a[j]) &#123;</span><br><span class="line">            j--; <span class="comment">// 向前寻找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            a[i] = a[j]; <span class="comment">// 将比第一个小的移到低端</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &gt;= a[i]) &#123;</span><br><span class="line">            i++; <span class="comment">// 向后寻找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            a[j] = a[i]; <span class="comment">// 将比第一个大的移到高端</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = key; <span class="comment">// 当在当组内找完一遍以后就把中间数key回归</span></span><br><span class="line">    </span><br><span class="line">    qsort(a, left, i - <span class="number">1</span>);</span><br><span class="line">    qsort(a, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>**1，简单选择排序：**面对一排数，假设第一个数是最小的，将第一个数依次与后面的所有数据进行比较，如发现更小的就把该数的下标记录下来，再将这个数与后面的数比较，一轮下来以后如果发现最小的数的下标不是第一个，就与第一个数交换，这样就保证了第一个位置上的数是最小的；对除去第一个数的剩下的数做同样的操作，多轮循环之后，直到剩下最后一个数，排序结束。<br>时间复杂度：O($n^2$)</p>
<figure class="highlight c"><figcaption><span>// 简单选择排序</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">simpleChoiceSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> m = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[m]) &#123; <span class="comment">// 如果第j个元素比第m个元素小，将j赋值给m</span></span><br><span class="line">                m = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != m) &#123; <span class="comment">// 交换m和i两个元素的位置</span></span><br><span class="line">            <span class="type">int</span> t = a[i];</span><br><span class="line">            a[i] = a[m];</span><br><span class="line">            a[m] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2，堆排序（heap sort）：</strong><br>堆有两个性质，一是堆中某个节点的值总是不大于或不小于其父节点的值，二是堆是一棵完全树。<br>以从大到小排序为例，首先要把得到的数组构建为一个最小堆，这样父节点均是小于或者等于子结点，根节点就是最小值，然后让根节点与尾节点交换，这样一次之后，再把前n－1个元素构建出最小根堆，让根结点与第n-2个元素交换，依此类推，得到降序序列。<br>时间复杂度：O(n$\log_2 n$)</p>
<figure class="highlight c"><figcaption><span>// 堆排序 从大到小排序</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 以i节点为根，调整为堆的算法，n是节点总数，i节点的子结点为i*2+1,i*2+2</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">nswap</span><span class="params">(<span class="type">int</span>&amp; i, <span class="type">int</span>&amp; j)</span> &#123;</span><br><span class="line">    i = i^j;</span><br><span class="line">    j = i^j;</span><br><span class="line">    i = i^j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapMin</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> least = i; <span class="comment">// 根节点,最小的</span></span><br><span class="line">    <span class="type">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> r = i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; n &amp;&amp; a[l] &lt; a[least])</span><br><span class="line">        least = l;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; n &amp;&amp; a[r] &lt; a[least])</span><br><span class="line">        least = r;</span><br><span class="line">    <span class="keyword">if</span> (least != i) &#123;</span><br><span class="line">        nswap(a[i], a[least]);</span><br><span class="line">        minHeapify(a, least, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapMin</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// i为根节点，j为左孩子，j+1为右孩子</span></span><br><span class="line">    <span class="type">int</span> tmp = a[i];</span><br><span class="line">    <span class="type">int</span> j = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j+<span class="number">1</span> &lt; n &amp;&amp; a[j+<span class="number">1</span>] &lt; a[j]) &#123; <span class="comment">// 在左右孩子中找最小的</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &gt;= tmp)  <span class="keyword">break</span>;</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        i = j;</span><br><span class="line">        j = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapMax</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// tmp保存根节点，j为左孩子编号</span></span><br><span class="line">    <span class="type">int</span> tmp = a[i];</span><br><span class="line">    <span class="type">int</span> j = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; j &lt; n; j = j*<span class="number">2</span>+<span class="number">1</span>) &#123; <span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">        <span class="keyword">if</span> (j+<span class="number">1</span> &lt; n &amp;&amp; a[j] &lt; a[j+<span class="number">1</span>]) &#123; <span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &gt; tmp) &#123; <span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            i = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = tmp; <span class="comment">//将tmp值放到最终的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// n/2-1最后一个非叶子节点</span></span><br><span class="line">    <span class="comment">// 下面这个操作是建立最小堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapMin(a, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for语句为输出堆顶元素，调整堆操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = n<span class="number">-1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">        <span class="comment">// 堆顶与堆尾交换</span></span><br><span class="line">        <span class="type">int</span> tmp = a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>] = a[j];</span><br><span class="line">        a[j] = tmp;</span><br><span class="line">        heapMin(a, <span class="number">0</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到的就是降序序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序（merge-sort）"><a href="#归并排序（merge-sort）" class="headerlink" title="归并排序（merge sort）"></a>归并排序（merge sort）</h3><p>**1，两路归并排序（Merge Sort）：**也就是我们常说的归并排序，也叫合并排序。归并操作即将两个顺序序列合并成一个顺序序列的方法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p>最差时间复杂度：O(n$\log_2 n$)<br>平均时间复杂度：O(n$\log_2 n$)<br>最差空间复杂度：O(n)<br>稳定性：稳定</p>
<p>归并操作的基本步骤如下：<br>1.申请两个与已经排序序列相同大小的空间，并将两个序列拷贝其中；<br>2.设定最初位置分别为两个已经拷贝排序序列的起始位置，比较两个序列元素的大小，依次选择相对小的元素放到原始序列；<br>3.重复2直到某一拷贝序列全部放入原始序列，将另一个序列剩下的所有元素直接复制到原始序列尾。</p>
<p>设归并排序的当前区间是a[low..high]，分治法的三个步骤是：<br>1.分解：将当前区间一分为二，即求分裂点<br>2.求解：递归地对两个子区间a[low..mid]和a[mid+1..high]进行归并排序；<br>3.组合：将已排序的两个子区间a[low..mid]和a[mid+1..high]归并为一个有序的区间a[low..high]。<br>递归的终结条件：子区间长度为1（一个记录自然有序）。</p>
<figure class="highlight c"><figcaption><span>// 归并子算法</span></figcaption><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 将有序的a[low...mid]和a[mid+1...high]归并为有序的tmp[low...high]</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> tmp[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = low;</span><br><span class="line">    <span class="type">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k = low;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i != mid + <span class="number">1</span> &amp;&amp; j != high + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt;= a[j]) &#123;</span><br><span class="line">            tmp[k++] = a[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[k++] = a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i != mid + <span class="number">1</span>) &#123;</span><br><span class="line">        tmp[k++] = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (j != high + <span class="number">1</span>) &#123;</span><br><span class="line">        tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = low; i &lt;= high; i++) &#123;</span><br><span class="line">        a[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两路归并排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> tmp[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(a, tmp, low, mid);</span><br><span class="line">        mergeSort(a, tmp, mid + <span class="number">1</span>, high);</span><br><span class="line">        merge(a, tmp, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基数排序（radix-sort）"><a href="#基数排序（radix-sort）" class="headerlink" title="基数排序（radix sort）"></a>基数排序（radix sort）</h3><p>时间复杂度：O(d(r+n))，r代表关键字的基数，d代表长度，n代表关键字的个数。</p>
<p>又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>
<p>最高位优先(Most Significant Digit first)法，简称MSD法：先按k1排序分组，同一组中记录，关键码k1相等，再对各组按k2排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd对各子组排序后。再将各组连接起来，便得到一个有序序列。</p>
<p>最低位优先(Least Significant Digit first)法，简称LSD法：先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。 </p>
<p>LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/category/880910.html">图解排序算法</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.lzxy169.com/2018/04/08/hexo-command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Navy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Navy's blog">
      <meta itemprop="description" content="It is about walking the path and responding to the heart.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Navy's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/08/hexo-command/" class="post-title-link" itemprop="url">Hexo 命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-08 14:10:08" itemprop="dateCreated datePublished" datetime="2018-04-08T14:10:08+08:00">2018-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2018-07-30 15:39:01" itemprop="dateModified" datetime="2018-07-30T15:39:01+08:00">2018-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hexo/" itemprop="url" rel="index"><span itemprop="name">Hexo</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new &quot;new article&quot;</span><br></pre></td></tr></table></figure>

<h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><p>草稿相当于很多博客都有的“私密文章”功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new draft &quot;new draft&quot;</span><br></pre></td></tr></table></figure>

<p>会在source&#x2F;drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动drafts目录之中。</p>
<p>如果你希望强行预览草稿，更改配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ render_drafts: true</span><br></pre></td></tr></table></figure>

<p>或者，如下方式启动server：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo server --drafts</span><br></pre></td></tr></table></figure>

<p>下面这条命令可以把草稿变成文章，或者页面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo -g #安装  </span><br><span class="line">npm update hexo -g #升级  </span><br><span class="line">hexo init #初始化</span><br></pre></td></tr></table></figure>

<h3 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章</span><br><span class="line">hexo p == hexo publish</span><br><span class="line">hexo g == hexo generate#生成</span><br><span class="line">hexo s == hexo server #启动服务预览</span><br><span class="line">hexo d == hexo deploy#部署</span><br></pre></td></tr></table></figure>

<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。</span><br><span class="line">hexo server -s #静态模式</span><br><span class="line">hexo server -p 5000 #更改端口</span><br><span class="line">hexo server -i 192.168.1.1 #自定义 IP</span><br><span class="line"></span><br><span class="line">hexo clean #清除缓存 网页正常情况下可以忽略此条命令</span><br><span class="line">hexo g #生成静态网页</span><br><span class="line">hexo d #开始部署</span><br></pre></td></tr></table></figure>

<h3 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate #使用 Hexo 生成静态文件快速而且简单</span><br><span class="line">hexo generate --watch #监视文件变动</span><br></pre></td></tr></table></figure>

<h3 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两个命令的作用是相同的</span><br><span class="line">hexo generate --deploy</span><br><span class="line">hexo deploy --generate</span><br><span class="line"></span><br><span class="line">hexo deploy -g</span><br><span class="line">hexo server -g</span><br></pre></td></tr></table></figure>

<h3 id="草稿-1"><a href="#草稿-1" class="headerlink" title="草稿"></a>草稿</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span><br><span class="line">hexo deploy #将.deploy目录部署到GitHub</span><br><span class="line"></span><br><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line">hexo new photo &quot;My Gallery&quot;</span><br><span class="line">hexo new &quot;Hello World&quot; --lang tw</span><br></pre></td></tr></table></figure>

<h3 id="模版（Scaffold）"><a href="#模版（Scaffold）" class="headerlink" title="模版（Scaffold）"></a>模版（Scaffold）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new photo &quot;My Gallery&quot;</span><br></pre></td></tr></table></figure>

<h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &lt;title&gt;</span><br><span class="line">hexo new post &lt;title&gt;</span><br></pre></td></tr></table></figure>

<h3 id="推送到服务器上"><a href="#推送到服务器上" class="headerlink" title="推送到服务器上"></a>推送到服务器上</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n #写文章</span><br><span class="line">hexo g #生成</span><br><span class="line">hexo d #部署 #可与hexo g合并为 hexo d -g</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2018 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Navy</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/lzxy169" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
